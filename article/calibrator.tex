\documentclass[review,authoryear]{elsarticle}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{pstricks}
\usepackage{multido}

\usepackage{lineno}
\linenumbers

\newcommand{\EQ}[2]
{\begin{equation}#1\end{equation}\label{#2}}

\newcommand{\PICTURE}[5]
{
	\begin{figure}[ht!]
		\centering
		\begin{picture}(#1,#2)
			#3
		\end{picture}
		\caption{#4.\label{#5}}
	\end{figure}
}

\newcommand{\PSPICTURE}[7]
{
	\begin{figure}[ht!]
		\centering
		\pspicture(#1,#2)(#3,#4)
			#5
		\endpspicture
		\caption{#6.\label{#7}}
	\end{figure}
}

\newcommand{\TABLE}[5]
{
	\begin{table}[ht!]
		\centering
		\caption{#4.\label{#5}}
		#1
		\begin{tabular}{#2}
			#3
		\end{tabular}
	\end{table}
}

\newcommand{\FIGII}[4]
{
	\begin{figure}[ht!]
		\centering
		\begin{tabular}{c}
			(a) \\ \includegraphics{#1} \\
			(b) \\ \includegraphics{#2}
		\end{tabular}
		\caption{#3.\label{#4}}
	\end{figure}
}

\newcommand{\FIGIV}[6]
{
	\begin{figure}[ht!]
		\centering
		\begin{tabular}{cc}
			(a) & (b)
			\\ \includegraphics{#1} & \includegraphics{#2}
			\\ (c) & (d)
			\\ \includegraphics{#3} & \includegraphics{#4}
		\end{tabular}
		\caption{#5.\label{#6}}
	\end{figure}
}

\newcommand{\FIGVI}[8]
{
	\begin{figure}[ht!]
		\centering
		\begin{tabular}{cc}
			(a) & (b)
			\\ \includegraphics{#1} & \includegraphics{#2}
			\\ (c) & (d)
			\\ \includegraphics{#3} & \includegraphics{#4}
			\\ (e) & (f)
			\\ \includegraphics{#5} & \includegraphics{#6}
		\end{tabular}
		\caption{#7.\label{#8}}
	\end{figure}
}

\bibliographystyle{elsarticle-harv}

\begin{document}

\title{CALIBRATOR: a software to perform optimizations or calibrations of
empirical parameters}

\author[eead,bifi]{J. Burguete\corref{cor1}}
\ead{jburguete@eead.csic.es}

\author[eead]{B. Latorre}
\ead{borja.latorre@csic.es}

\author[kit]{S. Ambroj}
\ead{samuel.ambroj@kit.edu}

\author[unizar]{A. Lacasta}
\ead{alacasta@unizar.es}

\author[eead]{S. Ouazaa}
\ead{sofiane.ouazaa@eead.csic.es}

\author[eead]{N. Zapata}
\ead{v.zapata@csic.es}

\author[unizar]{P. García-Navarro}
\ead{pigar@unizar.es}

\cortext[cor1]{Corresponding author}

\address[eead]{Soil and Water, EEAD / CSIC.
P.O. Box 13034, 50080~Zaragoza, Spain.}
\address[bifi]{BIFI: Instituto de Biocomputación y Física de Sistemas Complejos,
Universidad de Zaragoza.
Mariano Esquillor, Edificio I+D, 50009~Zaragoza, Spain.}
\address[kit]{Steinbuch Centre for Computing (SCC),
Karlsruhe Institute of Technology (KIT).
KIT-Campus Nord, Hermann von Helmholtzplatz 1, 76344 Eggenstein - Leopoldshafen,
Germany.}
\address[unizar]{Fluid Mechanics, LIFTEC, CSIC-Universidad de Zaragoza.
María de Luna 3, 50018~Zaragoza, Spain.}

\begin{keyword}
optimization, calibration, simulation, software, irrigation, sprinkler, furrow,
canal
\end{keyword}

\begin{abstract}
The present work describes CALIBRATOR, a new software program to perform
optimizations or calibrations of empirical parameters required in the
formulation of numerical simulation models. The structure is such that it can be
easily adapted to different simulation codes.
One genetic algorithm, two brute force optimization algorithms (sweeps and
Monte-Carlo) and an iterative algorithm to improve the brute force methods are
included.
Parallel computations are enabled in a simple way so that the work load can be
distributed among the different processors available in one computer or in
multiple computers of a cluster.
The CALIBRATOR usage and possibilities are illustrated by showing four practical
applications in agriculture: optimization of canal management and calibration of
the empirical infiltration coeffcients in a surface irrigation model, in a
ballistic sprinkler irrigation model and in an irrigation engines movement
model.
This software is open source and is distributed with a BSD (Berkeley Software
Distribution) type license.
\end{abstract}

\maketitle

\section{Introduction}

CALIBRATOR \citep{CalibratorGit} is an open source software to perform
optimizations or calibrations of empirical parameters with a BSD type license.

\section{Methods}

The following notation has been used:
\begin{description}
	\item[$N_{simulations}$]: number of simulations made on each step.
	\item[$N_{iterations}$]: number of iterations on iterative methods.
	\item[$N_{total}$]: total number of simulations.
\end{description}
On iterative methods $N_{total}=N_{simulations}\times N_{iterations}$.
On pure brute force methods
$N_{iterations}=1\;\Rightarrow\;N_{total}=N_{simulations}$.

\subsection{Sweep brute force method}

In the sweep method, the domain defined by the extreme values of the variables to optimize is divided in regular intervals. Then, a simulation is performed using each of the resulting combinations. (NO SE ENTIENDE). The sketch of an example is shown
in figure~\ref{FigSweep}.

The total number of required simulations is:
\EQ{N_{simulations}=x_{sweeps}\times y_{sweeps}\times\cdots,}
{EqNSweeps}
being $x_{sweeps}$ the number of sweeps in the variable $x$.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\multiput(50,40)(30,0){5}{\qbezier[40](0,0)(0,60)(0,120)}
	\multiput(50,40)(0,30){5}{\qbezier[40](0,0)(60,0)(120,0)}
	\multiput(50,40)(30,0){5}{\multiput(0,0)(0,30){5}{\circle*{2}}}
	\qbezier[10](50,10)(50,25)(50,40)
	\put(40,0){$x_{\min}$}
	\qbezier[10](170,10)(170,25)(170,40)
	\put(160,0){$x_{\max}$}
	\qbezier[10](20,40)(35,40)(50,40)
	\put(0,37){$y_{\min}$}
	\qbezier[10](20,160)(35,160)(50,160)
	\put(0,157){$y_{\max}$}
}{Diagram showing an example of application of the sweep brute force method
with two variables for $x_{sweeps}=y_{sweeps}=5$}{FigSweep}

\subsection{Monte-Carlo method}

Monte-Carlo based methods run simulations using aleatory values of the
variables assuming  uniform probability within the extrema values range. This is
an old brute force method attributed to different authors. In
\citet{AtanassovDimov08} an interesting analysis of this method is presented.
Figure~\ref{FigMonteCarlo} shows the structure of an example using two
variables.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\put(59,159){\circle*{2}}
	\put(153,73){\circle*{2}}
	\put(98,67){\circle*{2}}
	\put(129,154){\circle*{2}}
	\put(128,104){\circle*{2}}
	\put(119,131){\circle*{2}}
	\put(136,77){\circle*{2}}
	\put(60,102){\circle*{2}}
	\put(87,97){\circle*{2}}
	\put(65,66){\circle*{2}}
	\put(80,43){\circle*{2}}
	\put(153,63){\circle*{2}}
	\put(147,109){\circle*{2}}
	\put(99,119){\circle*{2}}
	\put(61,107){\circle*{2}}
	\put(54,75){\circle*{2}}
	\put(117,47){\circle*{2}}
	\put(116,127){\circle*{2}}
	\put(51,125){\circle*{2}}
	\put(52,123){\circle*{2}}
	\put(100,55){\circle*{2}}
	\put(74,64){\circle*{2}}
	\put(55,49){\circle*{2}}
	\put(49,105){\circle*{2}}
	\put(146,75){\circle*{2}}	
	\qbezier[50](50,10)(50,85)(50,160)
	\put(40,0){$x_{\min}$}
	\qbezier[50](170,10)(170,85)(170,160)
	\put(160,0){$x_{\max}$}
	\qbezier[50](20,40)(95,40)(170,40)
	\put(0,37){$y_{\min}$}
	\qbezier[50](20,160)(95,160)(170,160)
	\put(0,157){$y_{\max}$}
}{Diagram illustrating a Monte-Carlo brute force method with two variables and
$N_{simulations}=25$}{FigMonteCarlo}

\subsection{Iterative algorithm applied to brute force methods}

CALIBRATOR allows to iterate both sweep or Monte-Carlo brute force methods in order to
seek convergence. In this case, the best results from the previous
iteration are used to force new intervals in the variables for the following iteration. Then, for
$N_{best}^j$ the subset of the best simulation results in the $j$ iteration, the following quantities are 
defined:
\begin{description}
	\item[$\displaystyle x_{\max}^b=\max_{i\in N_{best}}x_i^j$]: Maximum value of variable $x$ 
in the subset of the best simulation results from the $j$ iteration.
\item[$\displaystyle x_{\min}^b=\max_{i\in N_{best}}x_i^j$]: Minimum value of variable $x$ in the subset of the best simulation results from the $j$ iteration.
\end{description}
A new interval in the variable $x$ is defined to build the optimization values in the next iteration between:
\[
	x_{\max}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		+\left(x_{\max}^b-x_{\min}^b\right)(1+tolerance)}{2},
\]
\[
	x_{\min}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		-\left(x_{\max}^b-x_{\min}^b\right)(1+tolerance)}{2},
\]
\EQ{x_i^{j+1}\in\left[x_{\min}^{j+1},\;x_{\max}^{j+1}\right],}
{EqIterationInterval}
being $tolerance$ a factor increasing the size of the variable intervals to
simulate the next iteration.
Figure~\ref{FigIterative} contains an example of the procedure used by the the iterative algorithm to modify the variables intervals in order to enforce convergence. 

\PICTURE{210}{400}
{
	\small
	\multiput(0,0)(0,200){2}
	{
		\put(20,10){\vector(0,1){180}}
		\put(20,10){\vector(1,0){180}}
		\put(10,190){$y$}
		\put(200,0){$x$}
	}
	\put(90,380){1st iteration}
	\put(50,370){*: bests results}
	\put(59,359){\circle*{2}}
	\put(153,273){\circle*{2}}
	\put(98,267){*}
	\put(129,354){\circle*{2}}
	\put(128,304){*}
	\put(119,331){\circle*{2}}
	\put(136,277){\circle*{2}}
	\put(60,302){\circle*{2}}
	\put(87,297){*}
	\put(65,266){\circle*{2}}
	\put(80,243){\circle*{2}}
	\put(153,263){\circle*{2}}
	\put(147,309){\circle*{2}}
	\put(99,319){*}
	\put(61,307){\circle*{2}}
	\put(54,275){\circle*{2}}
	\put(117,247){\circle*{2}}
	\put(116,327){\circle*{2}}
	\put(51,325){\circle*{2}}
	\put(52,323){\circle*{2}}
	\put(100,255){\circle*{2}}
	\put(74,264){\circle*{2}}
	\put(55,249){\circle*{2}}
	\put(49,305){\circle*{2}}
	\put(146,275){\circle*{2}}	
	\qbezier[50](50,210)(50,285)(50,360)
	\put(40,200){$x_{\min}^1$}
	\qbezier[50](170,210)(170,285)(170,360)
	\put(160,200){$x_{\max}^1$}
	\qbezier[50](20,240)(95,240)(170,240)
	\put(0,237){$y_{\min}^1$}
	\qbezier[50](20,360)(95,360)(170,360)
	\put(0,357){$y_{\max}^1$}
	\qbezier[21](89,272)(109.5,272)(130,272)
	\qbezier[21](89,324)(109.5,324)(130,324)
	\qbezier[26](89,272)(89,298)(89,324)
	\qbezier[26](130,272)(130,298)(130,324)
	\put(89,267){\vector(1,0){41}}
	\put(130,267){\vector(-1,0){41}}
	\put(90,255){$x_{\max}^b-x_{\min}^b$}
	\put(84.9,215){\vector(1,0){49.2}}
	\put(134.1,215){\vector(-1,0){49.2}}
	\put(90,220){$x_{\max}^2-x_{\min}^2$}
	\qbezier[20](89,272)(86.95,241)(84.9,210)
	\qbezier[20](130,272)(132.05,241)(134.1,210)
	\qbezier[23](89,272)(54.5,269.4)(20,266.8)
	\qbezier[23](89,324)(54.5,326.6)(20,329.2)
	\put(80,180){2nd iteration}
	\put(92,123){\circle*{2}}
	\put(131,83){\circle*{2}}
	\put(108,80){\circle*{2}}
	\put(121,121){\circle*{2}}
	\put(121,97){\circle*{2}}
	\put(117,110){\circle*{2}}
	\put(124,84){\circle*{2}}
	\put(93,96){\circle*{2}}
	\put(104,94){\circle*{2}}
	\put(95,79){\circle*{2}}
	\put(101,68){\circle*{2}}
	\put(131,78){\circle*{2}}
	\put(129,100){\circle*{2}}
	\put(109,104){\circle*{2}}
	\put(93,98){\circle*{2}}
	\put(90,83){\circle*{2}}
	\put(116,70){\circle*{2}}
	\put(116,108){\circle*{2}}
	\put(89,107){\circle*{2}}
	\put(90,106){\circle*{2}}
	\put(109,74){\circle*{2}}
	\put(99,78){\circle*{2}}
	\put(91,71){\circle*{2}}
	\put(89,98){\circle*{2}}
	\put(128,83){\circle*{2}}
	\qbezier[40](84.9,10)(84.9,69.6)(84.9,129.2)
	\put(74.9,0){$x_{\min}^2$}
	\qbezier[40](134.1,10)(134.1,69.6)(134.1,129.2)
	\put(124.1,0){$x_{\max}^2$}
	\qbezier[35](20,129.2)(77.05,129.2)(134.1,129.2)
	\put(0,126.2){$y_{\max}^2$}
	\qbezier[35](20,66.8)(77.05,66.8)(134.1,66.8)
	\put(0,63.8){$y_{\min}^2$}
}{Diagram representing an example of the iterative algorithm applied to a
Monte-Carlo brute force method with two variables for $N_{simulations}= 25$ and
two iterations}{FigIterative}

\subsection{Genetic method}

CALIBRATOR also offers the use of a genetic method GENETIC \citep{genetic} with its default algorithms.
They are based on the ideas in \citet{gaul}, but have been fully programmed involving more modern external libraries.
The code in GENETIC is also open source under BSD license. Figure~\ref{FigGeneticFlow} shows the flowchart of the genetic method implemented in GENETIC.

\psset{xunit=0.5mm,yunit=0.5mm}
\PSPICTURE{-120}{-185}{120}{20}
{
	\tiny
	\rput(0,15){Generation of $N_{population}$}
	\rput(0,10){random genomes}
	\psframe(-35,5)(35,20)
	\psline{->}(0,5)(0,0)
	\rput(0,-5){$generation=1$}
	\psframe(-25,-10)(25,0)
	\psline{->}(0,-10)(0,-15)
	\rput(0,-20){Simulation of the $N_{population}$}
	\rput(0,-25){entities}
	\psframe(-40,-30)(40,-15)
	\psline{->}(0,-30)(0,-35)
	\rput(0,-40){Sorting the $N_{population}$}
	\rput(0,-45){entities by objective function value}
	\psframe(-45,-50)(45,-35)
	\psline{->}(0,-50)(0,-55)
	\rput(0,-60){Eliminating the worst}
	\rput(0,-65){$N_{mutation}+N_{reproduction}+N_{adaptation}$ entities}
	\psframe(-65,-70)(65,-55)
	\psline{->}(0,-70)(-80,-75)
	\rput(-80,-80){Generation of $N_{mutation}$}
	\rput(-80,-85){new entities by mutation}
	\psframe(-115,-90)(-45,-75)
	\psline{->}(-80,-90)(-80,-95)
	\rput(-80,-100){Simulation of the $N_{mutation}$}
	\rput(-80,-105){new mutated entities}
	\psframe(-115,-110)(-45,-95)
	\psline{->}(0,-70)(0,-75)
	\rput(0,-80){Generation of $N_{reproduction}$}
	\rput(0,-85){new entities by reproduction}
	\psframe(-40,-90)(40,-75)
	\psline{->}(0,-90)(0,-95)
	\rput(0,-100){Simulation of the $N_{reproduction}$}
	\rput(0,-105){new reproduced entities}
	\psframe(-40,-110)(40,-95)
	\psline{->}(0,-70)(82.5,-75)
	\rput(82.5,-80){Generation of $N_{adaptation}$}
	\rput(82.5,-85){new entities by adaptation}
	\psframe(120,-90)(45,-75)
	\psline{->}(82.5,-90)(82.5,-95)
	\rput(82.5,-100){Simulation of the $N_{adaptation}$}
	\rput(82.5,-105){new adapted entities}
	\psframe(120,-110)(45,-95)
	\psline{->}(-80,-110)(0,-115)
	\psline{->}(0,-110)(0,-115)
	\psline{->}(82.5,-110)(0,-115)
	\rput(0,-120){Sorting the old $N_{survival}$ entities and the new}
	\rput(0,-125){$N_{mutation}+N_{reproduction}+N_{adaptation}$ entities}
	\rput(0,-130){by objective function values}
	\psframe(-65,-115)(65,-135)
	\psline{->}(0,-135)(0,-140)
	\rput(0,-145){Increase $+1$ $generation$}
	\psframe(-30,-140)(30,-150)
	\psline{->}(0,-150)(0,-155)
	\rput(0,-162.5){$generation<N_{generations}$?}
	\pspolygon(-50,-162.5)(0,-170)(50,-162.5)(0,-155)
	\psline{->}(-50,-162.5)(-120,-162.5)(-120,-62.5)(-65,-62.5)
	\rput(-60,-160){Yes}
	\rput(-5,-172.5){No}
	\psline{->}(0,-170)(0,-175)
	\rput(0,-180){Select the best entity}
	\psframe(-30,-185)(30,-175)
}{Flow diagram of the genetic method implemented in GENETIC}{FigGeneticFlow}

\subsubsection{The genome}

The variables to calibrate/optimize are coded in GENETIC using a bit chain
(genome). The larger the number of bits assigned to a variable the higher the resolution.
The number of bits assigned to each variable, and therefore the genome size, is fixed and the same for all the 
simulations. Figure~\ref{FigGenome} shows an example for the coding of three variables. The value assigned to a variable $x$ is determined by the allowed extreme values $x_{\min}$ and $x_{\max}$, the binary number assigned in the genome to variable $I_x$ and by the number of bits assigned to variable $N_x$ according to
the following formula:
\EQ{x=x_{\min}+\frac{I_x}{2^{N_x}}\,\left(x_{\max}-x_{\min}\right).}{EqGenome}

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{30}
{
	\scriptsize
	\rput(40,27){Genome}
	\rput(15,23){Variable 1}
	\pspolygon(0,15)(30,15)(30,20)(0,20)
	\rput(40,23){Variable 2}
	\pspolygon(30,15)(50,15)(50,20)(30,20)
	\rput(65,23){Variable 3}
	\pspolygon(50,15)(80,15)(80,20)(50,20)
	\psline{->}(10,12)(0,12)
	\rput(5,9){Less}
	\rput(5,6){significant}
	\rput(5,3){bit}
	\psline{->}(20,12)(30,12)
	\rput(25,9){More}
	\rput(25,6){significant}
	\rput(25,3){bit}
	\rput(2,17.5){1}
	\rput(4,17.5){0}
	\rput(6,17.5){0}
	\rput(8,17.5){1}
	\rput(10,17.5){0}
	\rput(12,17.5){0}
	\rput(14,17.5){1}
	\rput(16,17.5){1}
	\rput(18,17.5){1}
	\rput(20,17.5){1}
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
}{Example coding three variables to optimize into a
genome. The first and third variables have been coded with 14 bits, and the second
variable has been coded with 9 bits.}{FigGenome}

\subsubsection{Survival of the best individuals}

In a population with $N_{population}$ individuals, in the fist generation all the cases are simulated. The input variables are
taken from the genome of each individual. Next, in every generation, $N_{population}\times R_{mutation}$ individuals are generated by mutation, $N_{population}\times R_{reproduction}$ individuals are generated by reproduction and $N_{population}\times R_{adaptation}$ individuals are generated by adaptation. The individuals of the former population that obtained lower values in the evaluation function are replaced so that the best $N_{survival}$ individuals survive:
\EQ
{
	N_{survival}=N_{population}\times
	\left(1-R_{mutation}-R_{reproduction}-R_{adaptation}\right),
}{EqSurvival}
Obviously, to avoid negative survival population, the following condition has to
be hold:
\EQ{R_{mutation}+R_{reproduction}+R_{adaptation}\leq 1}{EqSurvivalCondition}
New individuals will be generated by mutation, reproduction and adaptation from the genomes of these best individuals and so on. Furthermore, the ancestors to generate new individuals are chosen among the surviving population.
CALIBRATOR uses a default aleatory criterion in GENETIC, with a probability linearly decreasing with the ordinal in the ordered set of surviving individuals (see figure~\ref{FigSelection}).

\PICTURE{250}{110}
{
	\put(10,20){\vector(0,1){80}}
	\put(10,20){\vector(1,0){235}}
	\put(0,102){Probability to be selected as parent}
	\put(0,0){Survival population sorted by objective function values}
	\multiput(20,20)(10,0){2}{\line(0,1){66}}
	\put(20,86){\line(1,0){10}}
	\put(17,10){1st}
	\multiput(40,20)(10,0){2}{\line(0,1){60}}
	\put(40,80){\line(1,0){10}}
	\put(37,10){2nd}
	\multiput(60,20)(10,0){2}{\line(0,1){54}}
	\put(60,74){\line(1,0){10}}
	\put(57,10){3rd}
	\multiput(80,20)(10,0){2}{\line(0,1){48}}
	\put(80,68){\line(1,0){10}}
	\put(77,10){4th}
	\multiput(100,20)(10,0){2}{\line(0,1){42}}
	\put(100,62){\line(1,0){10}}
	\put(97,10){...}
	\multiput(120,20)(10,0){2}{\line(0,1){36}}
	\put(120,56){\line(1,0){10}}
	\multiput(140,20)(10,0){2}{\line(0,1){30}}
	\put(140,50){\line(1,0){10}}
	\multiput(160,20)(10,0){2}{\line(0,1){24}}
	\put(160,44){\line(1,0){10}}
	\multiput(180,20)(10,0){2}{\line(0,1){18}}
	\put(180,38){\line(1,0){10}}
	\multiput(200,20)(10,0){2}{\line(0,1){12}}
	\put(200,32){\line(1,0){10}}
	\multiput(220,20)(10,0){2}{\line(0,1){6}}
	\put(220,26){\line(1,0){10}}
	\put(215,10){Last}
	\qbezier[54](10,90.5)(127.5,50.25)(245,20)
}{Probability of a survival entity to be selected as parent
of the new entities generated by mutation, reproduction or adaptation
algorithms}{FigSelection}

Total number of simulations performed by the genetic algorithm is:
\EQ
{
	N_{total}=N_{population}\,N_{generations}
	-\left(N_{generations}-1\right)\,N_{survival},
}{EqGeneticNumber}
with $N_{generations}$ the number of generations of new entities.

\subsubsection{Mutation algorithm}

In the mutation algorithm an identical copy of the parent genome is made except for a bit, randomly chosen with uniform probability, which is inverted. Figure~\ref{FigMutation} shows an example of the procedure.
\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{20}
{
	\scriptsize
	\rput(10,17.5){Parent}
	\pspolygon(20,15)(80,15)(80,20)(20,20)
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(30,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(50,17.5){1}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(10,2.5){Son}
	\pspolygon(20,0)(80,0)(80,5)(20,5)
	\rput(22,2.5){1}
	\rput(24,2.5){1}
	\rput(26,2.5){0}
	\rput(28,2.5){1}
	\rput(30,2.5){1}
	\rput(32,2.5){1}
	\rput(34,2.5){0}
	\rput(36,2.5){1}
	\rput(38,2.5){0}
	\rput(40,2.5){0}
	\rput(42,2.5){0}
	\rput(44,2.5){0}
	\rput(46,2.5){0}
	\rput(48,2.5){0}
	\rput(50,2.5){1}
	\rput(52,2.5){1}
	\rput(54,2.5){1}
	\rput(56,2.5){1}
	\rput(58,2.5){1}
	\rput(60,2.5){0}
	\rput(62,2.5){1}
	\rput(64,2.5){0}
	\rput(66,2.5){0}
	\rput(68,2.5){0}
	\rput(70,2.5){0}
	\rput(72,2.5){1}
	\rput(74,2.5){1}
	\rput(76,2.5){1}
	\rput(78,2.5){1}
	\psline{->}(50,15)(50,5)
	\rput(60,10){Mutation}
	\pspolygon(35,15)(37,15)(37,20)(35,20)
	\pspolygon(35,5)(37,5)(37,0)(35,0)
	\psline{->}(32,10)(36,10)(36,15)
	\psline{->}(32,10)(36,10)(36,5)
	\rput(16,10){Inversion of a random bit}
}{Diagram showing an example of the generation of a new entity by mutation}
{FigMutation}

\subsubsection{Reproduction algorithm}

The default algorithm in GENETIC, used by CALIBRATOR, selects two different parents with one of the least errors after the 
complete simulation of one generation. 
A new individual is then generated by sharing the common bits of both parents and a random election in the others.
The new child has the same number of bits as the parents and different genome. Figure~\ref{FigReproduction} shows a sketch
of the algorithm.

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{20}
{
	\scriptsize
	\multido{\rb=0+7.5,\rt=5+7.5}{3}
	{
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](20,\rb)(23,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](25,\rb)(29,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](45,\rb)(47,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](49,\rb)(51,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](59,\rb)(61,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](63,\rb)(67,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](71,\rb)(75,\rt)
	}
	\rput(10,17.5){1st parent}
	\psframe(20,15)(80,20)
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(30,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(50,17.5){1}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(10,2.5){2nd parent}
	\psframe(20,0)(80,5)
	\rput(22,2.5){1}
	\rput(24,2.5){0}
	\rput(26,2.5){0}
	\rput(28,2.5){1}
	\rput(30,2.5){0}
	\rput(32,2.5){0}
	\rput(34,2.5){1}
	\rput(36,2.5){1}
	\rput(38,2.5){1}
	\rput(40,2.5){1}
	\rput(42,2.5){1}
	\rput(44,2.5){1}
	\rput(46,2.5){0}
	\rput(48,2.5){1}
	\rput(50,2.5){1}
	\rput(52,2.5){0}
	\rput(54,2.5){0}
	\rput(56,2.5){0}
	\rput(58,2.5){0}
	\rput(60,2.5){0}
	\rput(62,2.5){0}
	\rput(64,2.5){0}
	\rput(66,2.5){0}
	\rput(68,2.5){1}
	\rput(70,2.5){1}
	\rput(72,2.5){1}
	\rput(74,2.5){1}
	\rput(76,2.5){0}
	\rput(78,2.5){0}
	\rput(10,10){Son}
	\psframe(20,7.5)(80,12.5)
	\rput(22,10){1}
	\rput(24,10){0}
	\rput(26,10){0}
	\rput(28,10){1}
	\rput(30,10){0}
	\rput(32,10){0}
	\rput(34,10){0}
	\rput(36,10){1}
	\rput(38,10){1}
	\rput(40,10){0}
	\rput(42,10){1}
	\rput(44,10){1}
	\rput(46,10){0}
	\rput(48,10){1}
	\rput(50,10){1}
	\rput(52,10){1}
	\rput(54,10){1}
	\rput(56,10){1}
	\rput(58,10){0}
	\rput(60,10){0}
	\rput(62,10){0}
	\rput(64,10){0}
	\rput(66,10){0}
	\rput(68,10){1}
	\rput(70,10){0}
	\rput(72,10){1}
	\rput(74,10){1}
	\rput(76,10){0}
	\rput(78,10){1}
	\psline{->}(50,5)(50,7.5)
	\psline{->}(50,15)(50,12.5)
	\psline{->}(10,5)(10,7.5)
	\psline{->}(10,15)(10,12.5)
}{Example of the generation of a new entity by
reproduction in the GENETIC default algorithm. Note that the identical bits in both parents (in grey) are also present in the son. The rest of the bits are random}{FigReproduction}

\subsubsection{Adaptation algorithm}

Another algorithm is included in GENETIC called "adaptation" although, in the
biological sense, it would be better a smooth mutation. First, one of the
variables codified in the genome is randomly selected with uniform probability.
Then, a bit is randomly chosen assuming a probability linearly decreasing with
the significance of the bit. The new individual receives a copy of the parent's
genome with the selected bit inverted. Figure~\ref{FigAdaptation} contains an
example.

\psset{unit=1mm}
\PSPICTURE{-30}{-7.5}{80}{30}
{
	\scriptsize
	\rput(-10,17.5){Parent}
	\rput(15,23){Variable 1}
	\psframe(0,15)(30,20)
	\rput(40,23){Variable 2}
	\psframe(30,15)(50,20)
	\rput(65,23){Variable 3}
	\psline{->}(55,28)(65,28)(65,26)
	\rput(35,28){Random selection of a variable}
	\psframe(55,21)(75,26)
	\psframe(50,15)(80,20)
	\psline{->}(10,12)(0,12)
	\rput(5,9){Less}
	\rput(5,6){significant}
	\rput(5,3){bit}
	\psline{->}(20,12)(30,12)
	\rput(25,9){More}
	\rput(25,6){significant}
	\rput(25,3){bit}
	\rput(2,17.5){1}
	\rput(4,17.5){0}
	\rput(6,17.5){0}
	\rput(8,17.5){1}
	\rput(10,17.5){0}
	\rput(12,17.5){0}
	\rput(14,17.5){1}
	\rput(16,17.5){1}
	\rput(18,17.5){1}
	\rput(20,17.5){1}
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(65,10){Probability of selection}
	\rput(65,7){of a bit}
	\psframe[fillcolor=gray,fillstyle=solid](77,0)(79,0.5)
	\psframe[fillcolor=gray,fillstyle=solid](75,0)(77,1.0)
	\psframe[fillcolor=gray,fillstyle=solid](73,0)(75,1.5)
	\psframe[fillcolor=gray,fillstyle=solid](71,0)(73,2.0)
	\psframe[fillcolor=gray,fillstyle=solid](69,0)(71,2.5)
	\psframe[fillcolor=gray,fillstyle=solid](67,0)(69,3.0)
	\psframe[fillcolor=gray,fillstyle=solid](65,0)(67,3.5)
	\psframe[fillcolor=gray,fillstyle=solid](63,0)(65,4.0)
	\psframe[fillcolor=gray,fillstyle=solid](61,0)(63,4.5)
	\psframe[fillcolor=gray,fillstyle=solid](59,0)(61,5.0)
	\psframe[fillcolor=gray,fillstyle=solid](57,0)(59,5.5)
	\psframe[fillcolor=gray,fillstyle=solid](55,0)(57,6.0)
	\psframe[fillcolor=gray,fillstyle=solid](53,0)(55,6.5)
	\psframe[fillcolor=gray,fillstyle=solid](51,0)(53,7.0)
	\rput(-10,-5){Son}
	\psframe(0,-2.5)(30,-7.5)
	\psframe(30,-2.5)(50,-7.5)
	\psframe(50,-2.5)(80,-7.5)
	\rput(2,-5){1}
	\rput(4,-5){0}
	\rput(6,-5){0}
	\rput(8,-5){1}
	\rput(10,-5){0}
	\rput(12,-5){0}
	\rput(14,-5){1}
	\rput(16,-5){1}
	\rput(18,-5){1}
	\rput(20,-5){1}
	\rput(22,-5){1}
	\rput(24,-5){1}
	\rput(26,-5){0}
	\rput(28,-5){1}
	\rput(32,-5){1}
	\rput(34,-5){0}
	\rput(36,-5){0}
	\rput(38,-5){0}
	\rput(40,-5){0}
	\rput(42,-5){0}
	\rput(44,-5){0}
	\rput(46,-5){0}
	\rput(48,-5){0}
	\rput(52,-5){1}
	\rput(54,-5){1}
	\rput(56,-5){0}
	\rput(58,-5){1}
	\rput(60,-5){0}
	\rput(62,-5){1}
	\rput(64,-5){0}
	\rput(66,-5){0}
	\rput(68,-5){0}
	\rput(70,-5){0}
	\rput(72,-5){1}
	\rput(74,-5){1}
	\rput(76,-5){1}
	\rput(78,-5){1}
	\psline{->}(-10,15)(-10,-2.5)
	\rput(-20,6.25){Adaptation}
	\psframe(55,-7.5)(57,-2.5)
	\psframe(55,15)(57,20)
}{Example of the generation of a new individual from a parent by adaptation}
{FigAdaptation}

This algorithm is rather similar to the mutation algorithm previously described but, since the probability to affect bits less significant is larger, so is the probability to produce small changes.

\section{Implementation}

\subsection{External libraries}

CALIBRATOR uses the following open source external libraries:

\begin{itemize}
\item\citet{libxml}: Library required to read the input file in XML format.
\item\citet{gsl}: Scientific library required to generate the pseudo-random numbers used by 
the genetic algorithms and the Monte-Carlo method.
\item\citet{glib}: Library required to implement some data,	to parse the input file templates and the routines used to parallelize the usage of the computer's processors.
\item\citet{openmpi} or \citet{mpich}: Optional libraries. When installed, one
of them is used to allow parallelization in multiple computers.
\end{itemize}

\subsection{Building the executable file from the source code}

The source code in CALIBRATOR is written in C language. This software has
been built and tested in the following operative systems:
Debian Linux 8.0,
DragonFly BSD 4.0.5,
FreeBSD 10.1,
NetBSD 6.1.5,
OpenBSD 5.7,
Windows 7\footnotemark[1],
and Windows 8.1\footnotemark[1].
Probably, this software can be built and it works in other operative systems,
software distributions or versions but it has not been tested.
\footnotetext[1]{Windows 7 and Windows 8.1 are trademarks of Microsoft
Corporation.}

In order to build the executable file from the source code, a C compiler (\citet{gcc} or \citet{clang}), the configuration systems \citet{autoconf} and \citet{automake}, the executable creation control program \citet{gnumake} and the external libraries previously listed are required. When using Microsoft Windows systems, the indications provided in \citet{install-unix} can be followed in order to install all these utilities.

Once all the tools installed, the GENETIC source code must be downloaded and it must be compiled following on a terminal:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ git clone https://github.com/jburguete/genetic.git
$ cd genetic/0.6.1
$ aclocal
$ autoconf
$ automake --add-missing
$ ./configure
$ make
\end{lstlisting}

The following step is to download the source code CALIBRATOR, to link it with GENETIC and compile together by means of:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ git clone https://github.com/jburguete/calibrator.git
$ cd calibrator/0.4.5
$ ln -s ../../genetic/0.6.1 genetic
$ aclocal
$ autoconf
$ automake --add-missing
$ ./configure
$ make
\end{lstlisting}

Some systems (such OpenBSD) might require extra options. In those cases follow the README files in both repositories.

\subsection{Command line format}

\begin{itemize}

\item Command line in sequential mode (where X is the number of threads to
execute):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item Command line in parallelized mode (where X is the number of threads to
open in every node):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ mpirun [MPI options] ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item The syntax of the simulator has to be:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./simulator_name input_file_1 [input_file_2] [...] output_file
\end{lstlisting}
There are two options for the output file. It can begin with a number indicating
the objective function value or it can be a results file that has to be
evaluated by an external program (the evaluator) comparing with an experimental
file.

\item In the last option of the former point, the syntax of the program to
evaluate the objective function has to be (where the results file has to begin
with the objective function value):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./evaluator_name simulated_file experimental_file results_file
\end{lstlisting}

\end{itemize}

\subsection{Organization of CALIBRATOR}

The structure used by CALIBRATOR is defined in the \emph{input data file},
where it is necessary to specify the number of experiments $N$ as well as
the number of input files $n$ required by the simulation program. In addition,
the values which determine the empirical parameters and the optimization
algorithm have to be defined in this very same file. Then, CALIBRATOR
reads the $N\times n$ template files, which are used to build the simulator
input files, substituting labels by empirical parameters created by the
optimization algorithm. The simulator can either directly compare with
the \emph{experimental data file} generating a file with the value of the
objective function or can create a results file that an external program
called \emph{evaluator} will compare to the \emph{experimental data file}
in order to generate the \emph{objective value file}.
Eventually, each \emph{objective value file} associated with the $N$ experiments
is combined by means of mean square error

Finalmente, cada \emph{objective value file} asociado a los $N$ experimentos es
combinado mendiante mean square error para el \emph{objective function value}
asociado a la combinación de parámetros empíricos. Todo este proceso se repite
para cada combinación de parámetros empíricos generada por el algoritmo de
optimización. Además, CALIBRATOR paraleliza las simulaciones de manera
automática usando todos los recursos disponibles de procesadores y computadores.
Véase un esquema de esta estructura en la figura~\ref{FigStructure}.

\psset{xunit=0.4mm,yunit=0.4mm}
\PSPICTURE{-20}{-90}{280}{55}
{
	\tiny
	\rput(15,5){Input data file}
	\psframe(-20,0)(50,10)
	\psline{->}(50,5)(60,5)
	\rput(15,-20){1st template file}
	\psframe(-20,-25)(50,-15)
	\psline{->}(50,-20)(60,-20)
	\rput(15,-30){$\cdots$}
	\rput(15,-40){$(N\times n)$-th template file}
	\psframe(-20,-45)(50,-35)
	\psline{->}(50,-40)(60,-40)
	\rput(75,-20){Calibrator}
	\psframe(60,-55)(90,15)
	\psline{->}(90,10)(100,25)
	\psline{->}(90,5)(100,5)
	\psline{->}(90,-45)(100,-55)
	\psline{->}(90,-50)(100,-75)
	\rput(120,5){$n$-th input file}
	\psframe(100,0)(140,10)
	\psline{->}(140,5)(150,5)
	\rput(120,15){$\cdots$}
	\rput(120,25){1st input file}
	\psframe(100,20)(140,30)
	\psline{->}(140,25)(145,25)(145,5)
	\rput(185,5){Simulator}
	\psframe(150,0)(220,10)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(185,10)(185,20)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(220,5)(230,7.5)
	\rput(185,25){Results file}
	\psframe(150,20)(220,30)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(220,25)(230,30)
	\rput(185,45){Experimental data file}
	\psframe(150,40)(220,50)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(220,45)(230,30)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(150,45)(145,45)(145,25)
	\rput(250,30){Evaluator}
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(250,25)(250,15)
	\psframe(230,25)(270,35)
	\rput(250,10){Objective}
	\rput(250,5){value file}
	\psframe(230,0)(270,15)
	\psline{->}(270,7.5)(280,7.5)(280,-90)(50,-90)(50,-80)
	\rput(50,-75){Objective function value}
	\psframe(15,-80)(85,-70)
	\psline{->}(50,-70)(75,-55)
	\rput(120,50){1st experiment}
	\psframe[linestyle=dotted](95,-5)(275,55)
	\rput(185,-15){$\cdots$}
	\rput(120,-75){$n$-th input file}
	\psframe(100,-80)(140,-70)
	\psline{->}(140,-75)(150,-75)
	\rput(120,-65){$\cdots$}
	\rput(120,-55){1st input file}
	\psframe(100,-60)(140,-50)
	\psline{->}(140,-55)(145,-55)(145,-75)
	\rput(185,-75){Simulator}
	\psframe(150,-80)(220,-70)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(185,-70)(185,-60)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(220,-75)(230,-72.5)
	\rput(185,-55){Results file}
	\psframe(150,-60)(220,-50)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(220,-55)(230,-50)
	\rput(185,-35){Experimental data file}
	\psframe(150,-40)(220,-30)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(220,-35)(230,-50)
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(150,-35)(145,-35)(145,-55)
	\rput(250,-50){Evaluator}
	\psline[linestyle=dashed,dash=2pt 1pt]{->}(250,-55)(250,-65)
	\psframe(230,-55)(270,-45)
	\rput(250,-70){Objective}
	\rput(250,-75){value file}
	\psframe(230,-80)(270,-65)
	\psline(270,-72.5)(280,-72.5)
	\rput(120,-30){$N$-th experiment}
	\psframe[linestyle=dotted](95,-85)(275,-25)
}{ Illustrative diagram of the interactions among CALIBRATOR, the input files
	and the simulation and evaluation programs}{FigStructure}

El formato con el que deben definirse el \emph{input data file} así como el de
los \emph{template files} se detalla en la siguiente subsección.

\subsection{Input files}

\subsubsection{Template files}

Supongamos que buscamos la optimización de $M$ parámetros empíricos que mejor
ajusten el resultado de $N$ experimentos. Supongamos también que el programa de
simulación requiere $n$ ficheros de entrada. Entonces debemos crear $N\times n$
template files que deben reproducir cada fichero de entrada asociado a cada
experimento. Cada uno de estos template files es analizado sintácticamente por
CALIBRATOR que sustituirá las siguientes etiquetas para generar los ficheros de
entrada para el programa de simulación:
\begin{description}
\item[@variableX@]: se sustituye por la etiqueta asociada a ese parámetro
	empírico que se define en el \emph{input data file};
\item[@valueX@]: se sustituye por el valor asociado a ese parámetro empírico que
	es calculado por el algoritmo de optimización;
\end{description}
donde en ambos casos $X$ corresponde al ordinal de uno de los $M$ parámetros
empíricos.

\subsubsection{Input data file}

The format of the input data file is:
\begin{lstlisting}[language=xml,basicstyle=\scriptsize]
<?xml version="1.0"/>
<calibrate simulator="simulator_name" evaluator="evaluator_name"
	algorithm="algorithm_type" simulations="simulations_number"
	iterations="iterations_number" tolerance="tolerance_value"
	bests="bests_number">
	<experiment name="data_file_1" template1="template_1_1"
		template2="template_1_2" .../>
	...
	<experiment name="data_file_N" template1="template_N_1"
		template2="template_N_2" .../>
	<variable name="variable_1" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
	...
	<variable name="variable_M" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
</calibrate>
\end{lstlisting}

The main XML node has to begin with the key label \emph{"calibrate"}. The
available fields are:
\begin{description}
	\item[simulator]: to indicate the simulator program.
	\item[evaluator]: optional. It specifies the evaluator program if required.
	\item[algorithm]: to set the optimization algorithm. Three value are available:
	\begin{description}
		\item[sweep]: sweep brute force algorithm. It requires for each variable:
		\begin{description}
			\item[sweeps]: number of sweeps to generate each variable in every
			experiment.
		\end{description}
	\item[Monte-Carlo]: Monte-Carlo brute force algorithm. It requires on the main
		XML node:
		\begin{description}
			\item[simulations]: number of simulations to run on each iteration in
			every experiment.
		\end{description}
	\item[genetic]: genetic algorithm. It requires the following parameters in the
		main XML node:
		\begin{description}
			\item[population]: number of population entities.
			\item[generations]: number of generations.
			\item[mutation]: mutation ratio.
			\item[reproduction]: reproduction ratio.
			\item[adaptation]: adaptation ratio.
		\end{description}
	And on each variable:
		\begin{description}
			\item[bits]: number of bits to encode each variable.
		\end{description}
	\end{description}
\item[iterations]: number of iterations (default 1) to perform the iterative
algorithm. It applies only on sweep and Monte-Carlo methods.
\item[bests]: number of bests simulations to calculate convergence interval on
next iteration for the iterative algorithm (default 1). It applies only on
sweep and Monte-Carlo methods.
\item[tolerance]: tolerance parameter to relax convergence interval of the
iterative algorithm (default 0). It applies only on sweep and Monte-Carlo
methods.
\end{description}

The first type of child XML nodes has to begin with the key label
\emph{"experiment"}. It details the experimental data and it has the fields:
\begin{description}
	\item[name]: name of the input data file with experimental results to calibrate.
	\item[templateX]: $X$-th input data file template for the simulation program.
\end{description}

The second type of child XML nodes has to begin with the key label
\emph{"variable"}. It specifies the variables data and it has the fields:
\begin{description}
	\item[name]: variable label. On the $X$-th variable, the program parse all input
file templates creating the input simulation files by replacing all
@variableX@ labels by this name.
\item[minimum, maximum]: variable extreme values. The program creates the input
simulation files by replacing all @valueX@ labels in the input file templates
by a value between these extreme values on the $X$-th variable, depending on the
optimization algorithm.
\item[absolute\_minimum, absolute\_maximum]: absolute variable extreme values.
On iterative methods, the tolerance can increase initial \emph{minimum} or
\emph{maximum} values in each iteration. These values are the extreme values
allowed to prevent to exceed the model parameter limits.
\item[format]: standard C-format string to set the format to save the variable
in the simulation input files.
\end{description}

\section{Practical applications}

In what follows, a few cases of practical application of CALIBRATOR in combination with
different simulation codes are presented. The will deal with the optimization
and/or calibration 
of variables in models used for open channel flow, surface irrigation, sprinkler irrigation or irrigation
engines movement.   

Most of cases have been run on a laptop computer equipped with an Intel(R) Core(TM) i7 M620 2.67GHz processor. 
Then, the computation was performed in four parallelized tasks to make the most of the processor's double nucleus with hyperthreading. Only on the optimization
of the management of the Violada canal, much more expensive computationally, the
Memento cluster of the BIFI has been used.

\subsection{Optimization of a canal management}

A real irrigation canal has been analysed in order to find out the optimal
values of two variables of interest which take into account the daily gate
opening modification time. The area of study is located in the North-east of
Spain, in the province of Huesca. It consists of the first 13657 meters of the
Canal de Violada. The studied stretch was designed for a maximum discharge of
6~m$^3$/s. This stretch delivers water to three irrigation communities:
Almudévar, Gurrea and El Temple. In figure~\ref{FigViolada} a diagram with the
gates and spillways positions is shown.
\psset{xunit=9mm,yunit=6mm}
\PSPICTURE{-1}{-2}{11.4}{2}
{
	\scriptsize
	\rput(-0.5,0){Inlet}
	\rput(10.7,0){Outlet}
	\psline(0,0)(10,0)
	\psline{->}(7.5,0)(7.5,-1)
	\rput(7.5,-1.4){Spillway}
	\psline{->}(10,0)(10,-1)
	\rput(10,-1.4){Spillway}
	\psline{->}(3,0)(3,1)
	\rput(3,1.4){Almudévar}
	\psline{->}(8.5,0)(7.5,1)
	\rput(7.5,1.4){Gurrea}
	\psline{->}(9,0)(10,1)
	\rput(10,1.4){El Temple}
	\psline{<->}(0,-0.3)(3,-0.3)
	\rput(1.5,-0.7){5007 m}
	\psline{<->}(3,-0.3)(7.5,-0.3)
	\rput(5.25,-0.7){8346 m}
	\psline{<->}(7.5,-0.3)(8.5,-0.3)
	\rput(8,-0.7){270 m}
	\psline{<->}(8.5,-0.3)(9,-0.3)
	\rput(8.75,-0.7){7 m}
	\psline{<->}(9,-0.3)(10,-0.3)
	\rput(9.5,-0.7){27 m}
}{Diagram showing the position of the two spillways and the three gates on the
Canal de Violada. The dimensions are not on scale for a better visualization}
{FigViolada}

Two cross sections can be distinguished in the channel, the new initial reach
and the last 304 meters. Both share the same bottom slope, $S_0$ = 0.00059 but
differ in the cross section dimensions, as shown in
Figure~\ref{FigCrossSections}, and in the value of the Gauckler-Manning
roughness coefficient (0.014 and 0.02~s~m$^{-1/3}$ for the first
and the final reaches respectively). The values correspond to polished and
coarse concrete \citep{Chow59}.
\psset{xunit=9mm,yunit=9mm}
\PSPICTURE{0}{-0.6}{12.7}{2.450}
{
	\psline(0,2.050)(0.615,0)(3.259,0)(3.874,2.050)
	\rput(1.937,1.025){New channel}
	\psline{<->}(0.615,-0.2)(3.259,-0.2)
	\rput(1.937,-0.4){2.644 m}
	\psline{<->}(0,2.250)(3.874,2.250)
	\rput(1.937,2.450){3.874 m}
	\psline{<->}(4.074,0)(4.074,2.050)
	\rput(4.774,1.025){2.050 m}
	\psline(5.5,1.8)(5.5,1.5)(7,0)(9.5,0)(11,1.5)(11,1.8)
	\rput(8.25,0.9){Old channel}
	\psline{<->}(5.5,2)(11,2)
	\rput(8.25,2.2){5.500 m}
	\psline{<->}(7,-0.2)(9.5,-0.2)
	\rput(8.25,-0.4){2.500 m}
	\psline{<->}(11.2,0)(11.2,1.5)
	\rput(11.9,0.75){1.500 m}
	\psline{<->}(11.2,1.5)(11.2,1.8)
	\rput(11.95,1.65){0.300 m}
}{Channel cross sections for the first stretch of 13353 m (New) and the last part of 304 m (Old)}{FigCrossSections}

Two key optimization variables have been studied: $\Delta t_A$ and
$\Delta t_{GT}$. Where $\Delta t_A$ takes into account the delay between the
modification time of the inlet discharge and the modification time in the
Almudévar gate and $\Delta t_{GT}$ takes into account the delay between the
inlet and Gurrea and Temple gates modification. Before the development of this 
study, the channel guards responsible for its management carried out the gates
opening using $\Delta t_A=$1h and $\Delta t_{GT}=$3h30m.

The initial conditions for the canal were a steady state with a discharge of
2~m$^3$/s. The objective of this work was to provide
the required daily discharge to the three important irrigation gates as well as
to keep a constant discharge of 2 m$^3$/s at the outlet gate. It is important to 
note that Gurrea and Temple gates are only separated by a few meters and are located
in the nearby of the outlet gate.

The required discharge at every gate for a modernization scenario to sprinkler irrigation was obtained after an elaborate 
field analysis. Taking into account the crop distribution, soil water retention properties, 
characteristics of the parcels and hydrants, the electricity cost depending on the hour of the day and the design of a 
reservoir in the area, seven different scenarios were obtained as a function of the historical irrigation requirements for 
the same period using real data \citet{Zapata09}. A 14 days period in one of the epochs with higher demand was selected from
one of these scenarios in order to optimize the channel management.

Each optimization, which executed a total number of 1024 simulations, took 
approximately 14 hours using 64 cores in the Memento cluster housed at BIFI.

Table~\ref{TabSwigs} displays the results obtained for the optimal coefficient
values and the corresponding value of the evaluation function, where the error
norm is defined as the root mean square error between demanded discharges and
supplied discharges multiplied by a factor of 10 in cases of channel overflow.
The results are similar among the different optimization methods.
Nevertheless, it can be observed that the iterative algorithm, applied to the 
brute force methods, has improved slightly the results for this canal management.
It is also remarkable the fact that the genetic algorithm has obtained the best
and the worst of the results, from which it can be deduced that this method
is sensitive to the election of the genetic parameters. With the channel
guards management this error norm is much higher, due not only to a greater error
in the desired outlet discharge but also to a slight overflow in one of the 
spillways of the canal.

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	\multicolumn{2}{c}{Manual management} & $\Delta t_A=3600$ s & 1.049056
	\\ & & $\Delta t_{GT}=12600$ s
	\\ \hline
	Sweeps & $N_{simulations}=1024$ & $\Delta t_A=3368$ s & 0.047170
	\\ & $N_{iterations}=1$ & $\Delta t_{GT}=3716$ s
	\\ \hline
	Sweeps & $N_{simulations}=256$ & $\Delta t_A=3329$ s & 0.047148
	\\ & $N_{iterations}=4$ & $\Delta t_{GT}=3742$ s
	\\ & $N_{bests}=20$ &
	\\ & $tol=0.1$
	\\ \hline
	Monte-Carlo & $N_{simulations}=1024$ & $\Delta t_A=3193$ s & 0.047183
	\\ & $N_{iterations}=1$ & $\Delta t_{GT}=3705$ s
	\\ \hline
	Monte-Carlo & $N_{simulations}=256$ & $\Delta t_A=3250$ s & 0.047139
	\\ & $N_{iterations}=4$ & $\Delta t_{GT}=3751$ s
	\\ & $N_{bests}=4$
	\\ & $tol=0.1$
	\\ \hline
	Genetic & $N_{population}=256$ & $\Delta t_A=3363$ s & 0.047135
	\\ & $N_{generations}=9$ & $\Delta t_{GT}=3752$ s
	\\ & $R_{mutation}=0.125$
	\\ & $R_{reproduction}=0.125$
	\\ & $R_{adaptation}=0.125$
	\\ \hline
	Genetic & $N_{population}=64$ & $\Delta t_A=3375$ s & 0.047252
	\\ & $N_{generations}=21$ & $\Delta t_{GT}=3599$ s
	\\ & $R_{mutation}=0.25$
	\\ & $R_{reproduction}=0.25$
	\\ & $R_{adaptation}=0.25$
	\\ \hline
}{Optimal empirical parameters and value of the evaluation function in the simulation of the Violada canal using program SWIGS and several optimization algorithms in CALIBRATOR with the same total number of simulations ($N_{total}=1024$)}
{TabSwigs}

Figure~\ref{FigSwigs} shows the supplied discharges at the inlet and at the different
gates using the default schedule developed by the channel guards and that one 
obtained in the best of our simulations. It can be observed that in both cases 
the desired discharge at the different gates in Almudévar, Gurrea and El Temple is supplied,
being propagated downstream some transitory peaks, affecting the outlet discharge.
This work confirmed that an optimized management reduces remarkably the amplitude and the duration of these undesired peaks.

\FIGII{Violada-contributions.eps}{Violada-optimized-contributions.eps}
{
	Temporal evolution of discharges supplied at inlet, outlet and gates as (a)
	using the opening times applied by the canal guards and (b) the optimum 
	opening times obtained in this work
}{FigSwigs}

\subsection{Calibration of empirical parameters on surface irrigation}

CALIBRATOR has also been used to find out the empirical parameters required by the friction, and infiltration
models used in the model SURCOS \citep{Surcos,SurcosGit,JaviSurcos3} for the simulation of the four furrow fertigation experiments published in \citet{JaviSurcos2}. The furrows were $100$ m long and they were simulated using 100 computational cells per furrow. The furrows were close together, they had the same geometry and the experiments were almost simultaneous, hence the soil properties were assumed uniform. 

The friction model used in SURCOS is the Gauckler-Manning model. The infiltration model is the Kostiakov-Lewis model. They require calibration of three coefficients: the Gauckler-Manning number $n$ and the infiltration parameters $K$ and $a$. In the original paper, a brute force method using 3000 simulations was applied, each of them including the four experiments. In the present work, the same number of simulations has been used with the calibration methods implemented in CALIBRATOR. The execution of 3000 simulations in the mentioned laptop computer took about 1h20m.  

Table~\ref{TabSurcos} displays the results obtained for the optimal coefficient values and the corresponding
value of the evaluation function, where the error norm is the same as in \citet{JaviSurcos2}. The results are similar among the different methods and also similar to those in the original paper. This is due to the existence of a relatively large region of combinations of the empirical parameters producing similar values in the evaluation function, thus preventing from an accurate convergence to the optimum set. However, it can be noticed that both the iterative method and the genetic methods produce better results than the Monte-Carlo method without iterations with the same total number of simulations.

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	Monte-Carlo & $N_{simulations}=3000$ & $n=0.0395$ & 0.3430
	\\ & $N_{iterations}=1$ & $K=7.861\cdot 10^{-4}$
	\\ & & $a=0.534$
	\\ \hline
	Monte-Carlo & $N_{simulations}=500$ & $n=0.0422$ & 0.3321
	\\ & $N_{iterations}=6$ & $K=9.994\cdot 10^{-4}$
	\\ & $N_{bests}=10$ & $a=0.497$
	\\ & $tol=0.2$
	\\ \hline
	Genetic & $N_{population}=750$ & $n=0.0399$ & 0.3339
	\\ & $N_{generations}=6$ & $K=9.907\cdot 10^{-4}$
	\\ & $R_{mutation}=0.2$ & $a=0.498$
	\\ & $R_{reproduction}=0.2$
	\\ & $R_{adaptation}=0.2$
	\\ \hline
	Genetic & $N_{population}=300$ & $n=0.0417$ & 0.3322
	\\ & $N_{generations}=31$ & $K=9.989\cdot 10^{-4}$
	\\ & $R_{mutation}=0.1$ & $a=0.496$
	\\ & $R_{reproduction}=0.1$
	\\ & $R_{adaptation}=0.1$
	\\ \hline
}{Optimal empirical parameters and value of the evaluation function in the simulation of the furrow irrigation cases in \citet{JaviSurcos2} using program SURCOS and several optimization algorithms in CALIBRATOR with the same total number of simulations}{TabSurcos}

Figure~\ref{FigSurcos} shows the results of the water depths and solute concentration from the simulation using the coefficients obtained by the Monte-Carlo method with $N_{iterations}=6$, compared with the experimental values.

\FIGVI{surcos-advance.eps}{surcos-depth.eps}{surcos-solute-q1.eps}
{surcos-solute-q2.eps}{surcos-solute-q3.eps}{surcos-solute-q4.eps}
{
	(a) Advance time profile, (b) inlet depth evolution and (c-f) solute
	concentration evolution at probes for the experiments Q1-Q4 described in
	\citet{JaviSurcos2} simulated with the optimal calibrated parameters obtained
	for the Monte-Carlo method with $N_{iterations}=6$ (see
	table~\ref{TabSurcos})
}{FigSurcos}

\subsection{Calibration of empirical parameters of the ballistic model on
sprinkler irrigation}

The ballistic model \citep{Fukui80,Playan06} is the most widespread o characterize the behaviour and performance of sprinklers in sprinkler irrigation management. The model assumes that the travelling drops are approximately spherical and subject to the resulting effect of gravity and drag forces. The ejecting drop velocity is required by the model, and it is frequent to assume that the jet is compact enough to consider that all the drops carry the same velocity when leaving the sprinkler. This velocity can be estimated either by measuring the pressure and using Bernoulli's equation or, alternatively, by measuring the discharge and dividing by the outlet cross section. Other data required to characterize the water spread are related to the drop size distribution. The model used in the present work, described in \cite{Ouazaa14}, is based on three parameters $D_{50}$, $n$ and $P$. Furthermore, to include the influence of the wind, the model includes two more aerodynamic resistance coefficients:
$k_1$ y $k_2$.
The model is calibrated in two steps. First, the coefficients $D_{50}$, $n$ and $P$ are fitted to adjust the water distribution in windless conditions and are considered representative of the sprinkler model at a given pressure. In a second step, the coefficients $k_1$ and $k_2$ fitting better the water distribution in wind conditions are found.

In the present example, a spray sprinkler Senninger N44 at a working pressure of 138 kPa will be calibrated. In this sprinkler model, the water jet impacts against a fixed plate. In order to estimate the water velocity after the impact, an image technique as described in \citet{Salvador09} was applied. According to this measurements, the head loss due to the impact against the plate was found to be of 50\%.

Table~\ref{TabSprinklerI} shows the results from the calibration of parameters $D_{50}$, $n$ and $P$ in windless conditions using a total number of 1000 simulations with different optimization algorithms. The computation time was around 7 minutes in the laptop computer. The results show that the best results are supplied by the iterative Monte-Carlo method followed by the genetic algorithms. In this case, the sweep method leads to worse results, mainly when supplied with the iterative method. 

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	Sweeps & $N_{simulations}=1000$ & $D_{50}=3.78$ mm & 2.54 mm
	\\ & $N_{iterations}=1$ & $n=17.778$
	\\ & & $P=0.556$
	\\ \hline
	Sweeps & $N_{simulations}=125$ & $D_{50}=3.50$ mm & 3.24 mm
	\\ & $N_{iterations}=8$ & $n=10.225$
	\\ & $N_{bests}=8$ & $P=0.364$
	\\ & $tol=0.4$
	\\ \hline
	Monte-Carlo & $N_{simulations}=1000$ & $D_{50}=3.07$ mm & 2.01 mm
	\\ & $N_{iterations}=1$ & $n=21.513$
	\\ & & $P=0.770$
	\\ \hline
	Monte-Carlo & $N_{simulations}=125$ & $D_{50}=3.06$ mm & 1.60 mm
	\\ & $N_{iterations}=8$ & $n=20.878$
	\\ & $N_{bests}=8$ & $P=0.388$
	\\ & $tol=0.4$
	\\ \hline
	Genetic & $N_{population}=250$ & $D_{50}=3.06$ mm & 1.71 mm
	\\ & $N_{generations}=6$ & $n=21.001$
	\\ & $R_{mutation}=0.2$ & $P=0.563$
	\\ & $R_{reproduction}=0.2$
	\\ & $R_{adaptation}=0.2$
	\\ \hline
	Genetic & $N_{population}=100$ & $D_{50}=3.06$ mm & 1.62 mm
	\\ & $N_{generations}=31$ & $n=19.963$
	\\ & $R_{mutation}=0.1$ & $P=0.377$
	\\ & $R_{reproduction}=0.1$
	\\ & $R_{adaptation}=0.1$
	\\ \hline
}{Optimal empirical parameters and value of the evaluation function in the case of the sprinkler irrigation
using different optimization algorithms in CALIBRATOR with the same number of total simulations}{TabSprinklerI}

Next, using the optimal $D_{50}=3.06$ mm, $n=20.878$ and $P=0.388$ obtained by the Monte-Carlo method (Monte-Carlo with 8 iterations, see table~\ref{TabSprinklerI}) the values of $k_1$ and $k_2$ are calibrated in an experiment with medium wind velocity of 2.84 m/s. The different algorithms in CALIBRATOR are used with a total number of 400 simulations in all cases. Their computational time was around 4 minutes in the laptop computer. In this case, the genetic algorithms provided the best results  (note that they provided identical results in two different configurations), although the rest of the methods reached similar values.

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	Sweeps & $N_{simulations}=400$ & $k_1=0.263$ & 12.17 mm
	\\ & $N_{iterations}=1$ & $k_2=0.105$
	\\ \hline
	Sweeps & $N_{simulations}=100$ & $k_1=0.284$ & 12.17 mm
	\\ & $N_{iterations}=4$ & $k_2=0.098$
	\\ & $N_{bests}=11$
	\\ & $tol=0.2$
	\\ \hline
	Monte-Carlo & $N_{simulations}=400$ & $k_1=0.396$ & 12.19 mm
	\\ & $N_{iterations}=1$ & $k_2=0.067$
	\\ \hline
	Monte-Carlo & $N_{simulations}=100$ & $k_1=0.370$ & 12.15 mm
	\\ & $N_{iterations}=4$ & $k_2=0.079$
	\\ & $N_{bests}=4$
	\\ & $tol=0.2$
	\\ \hline
	Genetic & $N_{population}=100$ & $k_1=0.400$ & 12.09 mm
	\\ & $N_{generations}=6$ & $k_2=0.070$
	\\ & $R_{mutation}=0.2$
	\\ & $R_{reproduction}=0.2$
	\\ & $R_{adaptation}=0.2$
	\\ \hline
	Genetic & $N_{population}=100$ & $k_1=0.400$ & 12.09 mm
	\\ & $N_{generations}=11$ & $k_2=0.070$
	\\ & $R_{mutation}=0.1$
	\\ & $R_{reproduction}=0.1$
	\\ & $R_{adaptation}=0.1$
	\\ \hline
}{Optimal parameters and values of the evaluations function in the experiment of the sprinkler irrigation under wind conditions of 2.84 m/s using different optimization algorithms implemented in CALIBRATOR with the same total number of simulations}{TabSprinklerII}

Finally, figure~\ref{FigSprinkler} shows the measured (in pluviometers) and simulated water distribution using the optimal parameters in windless and wind conditions of average velocity 2.84 m/s.

\FIGII{sprinkler-0.eps}{sprinkler-2,84.eps}
{(a) Radial pluviometry for non-wind conditions and (b) pluviometry at the two
pluviometers axes}{FigSprinkler}

\subsection{Calibration of empirical parameters of the movement of a sprinkler
center-pivot}

The movement of a center-pivot tower follows a chaotic pattern depending from the movement of the exterior tower, the tower start and stop angles and the start and stop velocities. In \citet{Ouazaa15} a model was proposed to simulate the tower movements and several controlled experiments  were carried out to measure them in a real field center-pivot. The exterior tower controls the movement, with a sequence of working periods that depend on the cycle period and the working percentage, both adjustable to reach a desired irrigation service. The rest of the towers move according to a complex pattern (see figure~\ref{FigPivotDiagram}). 

\psset{unit=1mm}
\PSPICTURE{-10}{-6}{93}{20}
{
	\rput(25,17){$\alpha_i<\alpha_{start}\;\Rightarrow\;T_i$ start}
	\rput(65,17){$\alpha_i>\alpha_{stop}\;\Rightarrow\;T_i$ stop}
	\psarc{->}(0,0){93}{0}{7}
	\psline(0,0)(20,0)(40,1)(60,2.5)(90,5.5)
	\pscircle*(20,0){0.5}
	\pscircle*(40,1){0.5}
	\pscircle*(60,2.5){0.5}
	\pscircle*(80,4.5){0.5}
	\pscircle*(0,0){1.0}
	\rput(0,-3){Centre}
	\rput(20,-3){$T_1$}
	\rput(40,-2){$T_2$}
	\rput(60,-0.5){$T_3$}
	\rput(80,1.5){$T_4$}
	\psarc(20,0){3}{2.86}{180}
	\psarc(40,1){3}{4.29}{177.14}
	\psarc(60,2.5){3}{5.71}{175.71}
	\rput(20,6){$\alpha_1$}
	\rput(40,7){$\alpha_2$}
	\rput(60,8.5){$\alpha_3$}
}{Example of movement of a centre-pivot irrigation engine with
four towers}{FigPivotDiagram}

The movement of a real pivot with four towers separated 50.11 m is next simulated and calibrated. The maximum linear velocity of each tower were measured to be: $v_1=0.02738$ m/s, $v_2=0.02824$ m/s, $v_3=0.03008$ m/s and $v_4=0.03753$ m/s.
The exterior tower is considerably faster as it carries less weight and produces less friction. The model includes four empirical parameters to calibrate: the average angles of start $\overline{\alpha_{start}}$ and stop $\overline{\alpha_{stop}}$, the uncertainty in these angles $\delta$ and the start and stop times $\tau$. In every tower cycle, the start and stop angles are obtained as:
\EQ
{
	\alpha_{start}=\overline{\alpha_{start}}+(r-0.5)\,\delta,\quad
	\alpha_{stop}=\overline{\alpha_{stop}}+(r-0.5)\,\delta,
}{EqPivotStartStop}
with $r$ a random number defined with uniform probability in the range $r\in[0,1)$. The same time $\tau$ is considered for start and stop, and the velocity
increases or decreases linearly (see figure~\ref{FigPivotVelocity}).

\psset{unit=1mm}
\PSPICTURE{-16}{-6}{75}{39}
{
	\scriptsize
	\psline{->}(0,0)(0,30)
	\psline{->}(0,0)(70,0)
	\rput(0,36){Tower}
	\rput(0,32){linear velocity}
	\rput(70,-3){Time}
	\psline(0,0)(10,0)(15,20)(25,20)(30,0)(45,0)(50,20)(60,20)(65,0)
	\rput(-8,22){Maximum}
	\rput(-8,18){velocity}
	\psline[linestyle=dotted](0,20)(15,20)
	\psline{<->}(10,23)(15,23)
	\rput(12.5,26){$\tau$}
	\psline{<->}(10,29)(30,29)
	\rput(20,35){Start}
	\rput(20,32){time}
	\psline{<->}(25,23)(30,23)
	\rput(27.5,26){$\tau$}
	\psline{<->}(30,23)(45,23)
	\rput(37.5,29){Stop}
	\rput(37.5,26){time}
}{Linear velocity of a centre-pivot tower on starts and stops}{FigPivotVelocity}

The start and stop times of each tower were measured in four experiments of 24 hours with the pivot working in cycles of 71s at 100\%, 52\%, 42\% y 27.48\%. The times were grouped in four histographs and the evaluation function was defined as the mean square error between the measured and simulated histographs.
Table~\ref{TabPivot} shows some of the results obtained in a total of 10000 simulations of each of the four experiments, taking around 50 minutes each in the same laptop computer used before.
%%%%%%%%%%%%%%%%%%%%%%
Los mejores resultados se obtuvieron con los algoritmos genéticos. Llama la
atención que, como en el resto de casos presentados, el algoritmo genético
obtiene mejores resultados con los valores más bajos de los coeficientes $R$.
Por otro lado, el algoritmo iterativo ha mejorado considerablemente los
resultados cuando se ha aplicado al método de Monte-Carlo pero ha perjudicado
ligeramente al método de barrido.
%%%%%%%%%%%%%%%%%%%%%%

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	Sweep & $N_{simulations}=10000$ & $\overline{\alpha_{start}}=179.910^\circ$
	& 9924.1
	\\ & $N_{iterations}=1$ & $\overline{\alpha_{stop}}=180.300^\circ$
	\\ & & $\delta=0.130^\circ$
	\\ & & $\tau=4.40$s
	\\ \hline
	Sweep & $N_{simulations}=625$ & $\overline{\alpha_{start}}=179.335^\circ$
	& 10443.4
	\\ & $N_{iterations}=16$ & $\overline{\alpha_{stop}}=179.735^\circ$
	\\ & $N_{bests}=10$ & $\delta=0.113^\circ$
	\\ & $tol=0.4$ & $\tau=4.08$s
	\\ \hline
	Monte-Carlo & $N_{simulations}=10000$
	& $\overline{\alpha_{start}}=179.768^\circ$ & 12899.4
	\\ & $N_{iterations}=1$ & $\overline{\alpha_{stop}}=180.177^\circ$
	\\ & & $\delta=0.139^\circ$
	\\ & & $\tau=3.77$s
	\\ \hline
	Monte-Carlo & $N_{simulations}=625$
	& $\overline{\alpha_{start}}=179.786^\circ$ & 9741.8
	\\ & $N_{iterations}=16$ & $\overline{\alpha_{stop}}=180.194^\circ$
	\\ & $N_{bests}=10$ & $\delta=0.122^\circ$
	\\ & $tol=0.1$ & $\tau=3.82$s
	\\ \hline
	Genetic & $N_{population}=1000$ & $\overline{\alpha_{start}}=179.800^\circ$
	& 9552.8
	\\ & $N_{generations}=16$ & $\overline{\alpha_{stop}}=180.190^\circ$
	\\ & $R_{mutation}=0.2$ & $\delta=0.137^\circ$
	\\ & $R_{reproduction}=0.2$ & $\tau=4.39$s
	\\ & $R_{adaptation}=0.2$
	\\ \hline
	Genetic & $N_{population}=400$ & $\overline{\alpha_{start}}=179.751^\circ$
	& 9187.5
	\\ & $N_{generations}=81$ & $\overline{\alpha_{stop}}=180.166^\circ$
	\\ & $R_{mutation}=0.1$ & $\delta=0.136^\circ$
	\\ & $R_{reproduction}=0.1$ & $\tau=3.32$s
	\\ & $R_{adaptation}=0.1$
	\\ \hline
}{Optimal parameters and values of the evaluation function in the four towers pivot case in \citet{Ouazaa15} using different optimization algorithms implemented in CALIBRATOR with the same number of total simulations}{TabPivot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
In figures \ref{FigPivot100} to \ref{FigPivot27} the histographs of the number
of measured and simulated starts and stops are represented for the different
machine workings. El acuerdo entre los resultados medidos y simulados, con los
parámetros calibrados con el algoritmo genético óptimo, deben considerarse
razonables dada la extrema caoticidad del movimiento.
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FIGIV{pivot-measured-starts-100.eps}{pivot-measured-stops-100.eps}
{pivot-simulated-starts-100.eps}{pivot-simulated-stops-100.eps}
{Histograph of the number of (a) measured starts, (b) measured stops, (c)
simulated starts and (d) simulated stops for the pivot towers working at 100\%
velocity}{FigPivot100}

\FIGIV{pivot-measured-starts-52.eps}{pivot-measured-stops-52.eps}
{pivot-simulated-starts-52.eps}{pivot-simulated-stops-52.eps}
{Histograph of the number of (a) measured starts, (b) measured stops, (c)
simulated starts and (d) simulated stops for the pivot towers working at 52\%
velocity}{FigPivot52}

\FIGIV{pivot-measured-starts-42.eps}{pivot-measured-stops-42.eps}
{pivot-simulated-starts-42.eps}{pivot-simulated-stops-42.eps}
{Histograph of the number of (a) measured starts, (b) measured stops, (c)
simulated starts and (d) simulated stops for the pivot towers working at 42\%
velocity}{FigPivot42}

\FIGIV{pivot-measured-starts-27,48.eps}{pivot-measured-stops-27,48.eps}
{pivot-simulated-starts-27,48.eps}{pivot-simulated-stops-27,48.eps}
{Histograph of the number of (a) measured starts, (b) measured stops, (c)
simulated starts and (d)simulated stops for the pivot towers working at 27.48\% velocity}{FigPivot27}

\section{Conclusions}

The features and design of CALIBRATOR, a new software tool to enable efficient calibration and optimization of empirical coefficients present in simulation models has been presented. The program includes the option of two classic brute force models, the sweep and the Monte-Carlo method, both supplied with the option of an iterative procedure to improve convergence. Also, CALIBRATOR offers the alternative of a genetic algorithm as implemented in GENETIC.

The new tool allows an efficient performance, making the most of the processors present in a single computer and allowing an easy extension to parallelization distributed among different computers. In whole, a considerable data capacity and computational speed are achieved with independence of the physical problem under study or the algorithm chosen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
En los casos analizados, los diferentes algoritmos de optimización implementados han obtenido resultados similares con el mismo número total de simulaciones. No obstante, el algoritmo iterativo aplicado con el método de Monte-Carlo y el algoritmo genético han mejorado ligeramente los resultados de los métodos de fuerza bruta. El algoritmo iterativo no ha mejorado significativamente en cambio los resultados del método de barrido. En cuanto al algoritmo genético siempre ha dado mejores resultados con los valores más bajos ensayados para los coeficientes $R$. Esto parece indicar que la eficacia de este algoritmo es dependiente del valor de estos coeficientes y que una mayor investigación sobre su valor óptimo debería ser realizada.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

CALIBRATOR has proved to be flexible in the adaptation to the syntax of diverse simulation codes and useful in the calibration and optimization of parameters involved in rather different irrigation problems. In the present work it has been shown successful for practical applications such as open channel flow management, furrow fertigation, sprinkler irrigation and sprinkler tower movement design.


\section*{References}
\bibliography{bib}

\end{document}

