\documentclass[review,authoryear]{elsarticle}

\usepackage[utf8]{inputenc}
\usepackage{listings}

\usepackage{lineno}
\linenumbers

\newcommand{\EQ}[2]
{\begin{equation}#1\end{equation}\label{#2}}

\newcommand{\PICTURE}[5]
{
	\begin{figure}[ht!]
		\centering
		\begin{picture}(#1,#2)
			#3
		\end{picture}
		\caption{#4.\label{#5}}
	\end{figure}
}

\title{CALIBRATOR: a software to perform calibrations or optimizations of
empirical parameters}

\author{J. Burguete, B. Latorre, S. Ambroj, A. Lacasta, S. Ouazaa,
P. García-Navarro}
 
\date{\today}

\bibliographystyle{elsarticle-harv}

\begin{document}

\maketitle

\section{Introduction}

CALIBRATOR \cite{CalibratorGit} is an open source software to perform
calibrations or optimizations of empirical parameters with a BSD (Berkeley
Software Distribution) type license.

\section{Methods}

\subsection{Sweep brutal force method}

El método de barrido divide el espacio entre los valores extremos de las
variables en intervalos regulares y realiza una simulación para cada una de las
combinaciones de variables resultantes. Véase un esquema en la
figura~\ref{FigSweep}. El número total de simulaciones que realiza es:
\EQ{N_{simulations}=x_{sweeps}\times y_{sweeps}\times\cdots,}{EqNSweeps}
siendo $x_{sweeps}$ el número de barridos en la variable $x$.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\multiput(50,40)(30,0){5}{\qbezier[40](0,0)(0,60)(0,120)}
	\multiput(50,40)(0,30){5}{\qbezier[40](0,0)(60,0)(120,0)}
	\multiput(50,40)(30,0){5}{\multiput(0,0)(0,30){5}{\circle*{2}}}
	\qbezier[10](50,10)(50,25)(50,40)
	\put(40,0){$x_{\min}$}
	\qbezier[10](170,10)(170,25)(170,40)
	\put(160,0){$x_{\max}$}
	\qbezier[10](20,40)(35,40)(50,40)
	\put(0,37){$y_{\min}$}
	\qbezier[10](20,160)(35,160)(50,160)
	\put(0,157){$y_{\max}$}
}{Sweep brutal force method with two variables}{FigSweep}

\subsection{Monte-Carlo method}

El método de Monte-Carlo realiza simulaciones de variables obtenidas
aleatoriamente con probabilidad uniforme en el rango comprendido entre los
valores extremos. En la figura~\ref{FigMonteCarlo} vemos el esquema de un
ejemplo con dos variables.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\put(59,159){\circle*{2}}
	\put(153,73){\circle*{2}}
	\put(98,67){\circle*{2}}
	\put(129,154){\circle*{2}}
	\put(128,104){\circle*{2}}
	\put(119,131){\circle*{2}}
	\put(136,77){\circle*{2}}
	\put(60,102){\circle*{2}}
	\put(87,97){\circle*{2}}
	\put(65,66){\circle*{2}}
	\put(80,43){\circle*{2}}
	\put(153,63){\circle*{2}}
	\put(147,109){\circle*{2}}
	\put(99,119){\circle*{2}}
	\put(61,107){\circle*{2}}
	\put(54,75){\circle*{2}}
	\put(117,47){\circle*{2}}
	\put(116,127){\circle*{2}}
	\put(51,125){\circle*{2}}
	\put(52,123){\circle*{2}}
	\put(100,55){\circle*{2}}
	\put(74,64){\circle*{2}}
	\put(55,49){\circle*{2}}
	\put(49,105){\circle*{2}}
	\put(146,75){\circle*{2}}	
	\qbezier[50](50,10)(50,85)(50,160)
	\put(40,0){$x_{\min}$}
	\qbezier[50](170,10)(170,85)(170,160)
	\put(160,0){$x_{\max}$}
	\qbezier[50](20,40)(95,40)(170,40)
	\put(0,37){$y_{\min}$}
	\qbezier[50](20,160)(95,160)(170,160)
	\put(0,157){$y_{\max}$}
}{Monte-Carlo brutal force method with two variables}{FigMonteCarlo}

\subsection{Iterative algorithm applied to brutal force methods}

CALIBRATOR allows to iterate both brutal force methods (sweep or Monte-Carlo) to
increase the convergence. In this case, the bests results of the previous
iteration are used to force new intervals in the variables. Then, para
$N_{bests}^j$ el subconjunto de las mejores simulaciones de la $j$-ésima
iteración, definimos las siguientes magnitudes:
\begin{description}
\item{$\displaystyle x_{\max}^b=\max_{i\in N_{bests}}x_i^j$}: máximo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\item{$\displaystyle x_{\min}^b=\max_{i\in N_{bests}}x_i^j$}: mínimo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\end{description}
El nuevo intervalo en la variable $x$ en el que se simulará la siguiente
iteración estará comprendido entre:
\[
	x_{\max}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		+\left(x_{\max}^b-x_{\min}^b\right)(1+tolerance)}{2},
\]
\[
	x_{\min}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		-\left(x_{\max}^b-x_{\min}^b\right)(1+tolerance)}{2},
\]
\EQ{x_i^{j+1}\in\left[x_{\min}^{j+1},\;x_{\max}^{j+1}\right].}
{EqIterationInterval}
En la figura~\ref{FigIterative} se ilustra el procedimiento con el que el
algoritmo iterativo modifica los intervalos de las variables para incrementar la
convergencia.

\PICTURE{210}{400}
{
	\small
	\multiput(0,0)(0,200){2}
	{
		\put(20,10){\vector(0,1){180}}
		\put(20,10){\vector(1,0){180}}
		\put(10,190){$y$}
		\put(200,0){$x$}
	}
	\put(90,380){1st iteration}
	\put(50,370){*: bests results}
	\put(59,359){\circle*{2}}
	\put(153,273){\circle*{2}}
	\put(98,267){*}
	\put(129,354){\circle*{2}}
	\put(128,304){*}
	\put(119,331){\circle*{2}}
	\put(136,277){\circle*{2}}
	\put(60,302){\circle*{2}}
	\put(87,297){*}
	\put(65,266){\circle*{2}}
	\put(80,243){\circle*{2}}
	\put(153,263){\circle*{2}}
	\put(147,309){\circle*{2}}
	\put(99,319){*}
	\put(61,307){\circle*{2}}
	\put(54,275){\circle*{2}}
	\put(117,247){\circle*{2}}
	\put(116,327){\circle*{2}}
	\put(51,325){\circle*{2}}
	\put(52,323){\circle*{2}}
	\put(100,255){\circle*{2}}
	\put(74,264){\circle*{2}}
	\put(55,249){\circle*{2}}
	\put(49,305){\circle*{2}}
	\put(146,275){\circle*{2}}	
	\qbezier[50](50,210)(50,285)(50,360)
	\put(40,200){$x_{\min}^1$}
	\qbezier[50](170,210)(170,285)(170,360)
	\put(160,200){$x_{\max}^1$}
	\qbezier[50](20,240)(95,240)(170,240)
	\put(0,237){$y_{\min}^1$}
	\qbezier[50](20,360)(95,360)(170,360)
	\put(0,357){$y_{\max}^1$}
	\qbezier[21](89,272)(109.5,272)(130,272)
	\qbezier[21](89,324)(109.5,324)(130,324)
	\qbezier[26](89,272)(89,298)(89,324)
	\qbezier[26](130,272)(130,298)(130,324)
	\put(89,267){\vector(1,0){41}}
	\put(130,267){\vector(-1,0){41}}
	\put(90,255){$x_{\max}^b-x_{\min}^b$}
	\put(84.9,215){\vector(1,0){49.2}}
	\put(134.1,215){\vector(-1,0){49.2}}
	\put(90,220){$x_{\max}^2-x_{\min}^2$}
	\qbezier[20](89,272)(86.95,241)(84.9,210)
	\qbezier[20](130,272)(132.05,241)(134.1,210)
	\qbezier[23](89,272)(54.5,269.4)(20,266.8)
	\qbezier[23](89,324)(54.5,326.6)(20,329.2)
	\put(80,180){2nd iteration}
	\put(92,123){\circle*{2}}
	\put(131,83){\circle*{2}}
	\put(108,80){\circle*{2}}
	\put(121,121){\circle*{2}}
	\put(121,97){\circle*{2}}
	\put(117,110){\circle*{2}}
	\put(124,84){\circle*{2}}
	\put(93,96){\circle*{2}}
	\put(104,94){\circle*{2}}
	\put(95,79){\circle*{2}}
	\put(101,68){\circle*{2}}
	\put(131,78){\circle*{2}}
	\put(129,100){\circle*{2}}
	\put(109,104){\circle*{2}}
	\put(93,98){\circle*{2}}
	\put(90,83){\circle*{2}}
	\put(116,70){\circle*{2}}
	\put(116,108){\circle*{2}}
	\put(89,107){\circle*{2}}
	\put(90,106){\circle*{2}}
	\put(109,74){\circle*{2}}
	\put(99,78){\circle*{2}}
	\put(91,71){\circle*{2}}
	\put(89,98){\circle*{2}}
	\put(128,83){\circle*{2}}
	\qbezier[40](84.9,10)(84.9,69.6)(84.9,129.2)
	\put(74.9,0){$x_{\min}^2$}
	\qbezier[40](134.1,10)(134.1,69.6)(134.1,129.2)
	\put(124.1,0){$x_{\max}^2$}
	\qbezier[35](20,129.2)(77.05,129.2)(134.1,129.2)
	\put(0,126.2){$y_{\max}^2$}
	\qbezier[35](20,66.8)(77.05,66.8)(134.1,66.8)
	\put(0,63.8){$y_{\min}^2$}
}{Iterative algorithm applied to a Monte-Carlo brutal force method with two
variables}{FigIterative}

\subsection{Genetic method}

El algoritmo genético implementado en CALIBRATOR 
Los algoritmos están inspirados en \cite{gaul}, aunque han sido completamente
reescritos con muchas simplificaciones y haciendo uso de modernas librerías
externas. El código del algoritmo está publicado de forma independiente en
\cite{genetic} y también es open source bajo licencia de tipo BSD.

\subsubsection{Mutation algorithm}

\subsubsection{Reproduction algorithm}

\subsubsection{Adaptation algorithm}

\section{Implementation}

\subsection{External libraries}

CALIBRATOR hace uso de las siguientes librerías externas:

\begin{itemize}
\item\cite{libxml}: librería open source requerida para leer el fichero
	de entrada que usa el formato XML.
\item\cite{gsl}: librería científica open source requeridad para generar
	los números pseudo-aleatorios que usan los algoritmos genético y de
	Monte-Carlo.
\item\cite{glib}: librería open source requerida para implementar algunos
	tipos de datos y las tareas con las que el programa paraleliza el uso de los
	múltiples procesadores de la máquina.
\item\cite{openmpi,mpich}: librerías open source opcionales. En
	el caso de estar alguna de ellas instaladas en el sistema, el programa la
	utiliza para permitir el uso paralelizado en múltiple máquinas.
\end{itemize}

\subsection{Command line format}

\begin{itemize}

\item Command line in sequential mode (where X is the number of threads to
execute):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item Command line in parallelized mode (where X is the number of threads to
open in every node):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ mpirun [MPI options] ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item The sintaxis of the simulator has to be:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./simulator_name input_file_1 [input_file_2] [...] output_file
\end{lstlisting}

\item The sintaxis of the program to evaluate the objetive function has to be (where
the first data in the results file has to be the objective function value):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./evaluator_name simulated_file data_file results_file
\end{lstlisting}

\end{itemize}

\subsubsection{Input data file}

The format of the input data file is:
\begin{lstlisting}[language=xml,basicstyle=\scriptsize]
<?xml version="1.0"/>
<calibrate simulator="simulator_name" evaluator="evaluator_name"
	algorithm="algorithm_type" simulations="simulations_number">
	<experiment name="data_file_1" template1="template_1_1"
		template2="template_1_2" template3="template_1_3"
		template4="template_1_4"/>
	...
	<experiment name="data_file_N" template1="template_N_1"
		template2="template_N_2" template3="template_N_3"
		template4="template_N_4"/>
	<variable name="variable_1" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
	...
	<variable name="variable_M" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
</calibrate>
\end{lstlisting}

\section{Practical applications}

\subsection{Calibration of empirical parameters on surface irrigation}

\subsection{Optimization of a canal management}

\subsection{Calibration of empirical parameters on sprinkler irrigation}

\section{Conclusions}

\bibliography{bib}

\end{document}
Implemented algorithms are:

* *"sweep"*: Sweep brutal force algorithm. Requires on each variable:
> sweeps: number of sweeps to generate on each variable in every experiment. 
>
> The total number of simulations to run is:
>
>> (number of experiments) x (variable 1 number of sweeps) x ... x
>> (variable n number of sweeps) x (number of iterations)

* *"Monte-Carlo"*: Monte-Carlo brutal force algorithm. Requires on calibrate:
> simulations: number of simulations to run in every experiment.
>
> The total number of simulations to run is:
>
>> (number of experiments) x (number of simulations) x (number of iterations)

* Both brutal force algorithms can be iterated to improve convergence by using
the following parameters:
> bests: number of bests simulations to calculate convergence interval on next
> iteration (default 1).
>
> tolerance: tolerance parameter to increase convergence interval (default 0).
>
> iterations: number of iterations (default 1).

* *"genetic"*: Genetic algorithm. Requires installation of genetic and the
following parameters:
> population: number of population.
>
> generations: number of generations.
>
> mutation: mutation ratio.
>
> reproduction: reproduction ratio.
>
> adaptation: adaptation ratio.
>
> And on each variable:
>
>> bits: number of bits to encode each variable.

