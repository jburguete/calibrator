\documentclass[review,authoryear]{elsarticle}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{pstricks}
\usepackage{multido}
\usepackage{multirow}

\usepackage{lineno}
\linenumbers

\newcommand{\EQ}[2]
{\begin{equation}#1\end{equation}\label{#2}}

\newcommand{\PICTURE}[5]
{
	\begin{figure}[ht!]
		\centering
		\begin{picture}(#1,#2)
			#3
		\end{picture}
		\caption{#4.\label{#5}}
	\end{figure}
}

\newcommand{\PSPICTURE}[7]
{
	\begin{figure}[ht!]
		\centering
		\pspicture(#1,#2)(#3,#4)
			#5
		\endpspicture
		\caption{#6.\label{#7}}
	\end{figure}
}

\newcommand{\TABLE}[5]
{
	\begin{table}[ht!]
		\centering
		\caption{#4.\label{#5}}
		#1
		\begin{tabular}{#2}
			#3
		\end{tabular}
	\end{table}
}

\newcommand{\FIGVI}[8]
{
	\begin{figure}[ht!]
		\centering
		\begin{tabular}{cc}
			(a) & (b)
			\\ \includegraphics{#1} & \includegraphics{#2}
			\\ (c) & (d)
			\\ \includegraphics{#3} & \includegraphics{#4}
			\\ (e) & (f)
			\\ \includegraphics{#5} & \includegraphics{#6}
		\end{tabular}
		\caption{#7.\label{#8}}
	\end{figure}
}

\bibliographystyle{elsarticle-harv}

\begin{document}

\title{CALIBRATOR: a software to perform calibrations or optimizations of
empirical parameters}

\author[eead,bifi]{J. Burguete\corref{cor1}}
\ead{jburguete@eead.csic.es}

\author[eead]{B. Latorre}
\ead{borja.latorre@csic.es}

\author[kit]{S. Ambroj}
\ead{samuel.ambroj@kit.edu}

\author[unizar]{A. Lacasta}
\ead{alacasta@unizar.es}

\author[eead]{S. Ouazaa}
\ead{sofiane.ouazaa@eead.csic.es}

\author[eead]{N. Zapata}
\ead{v.zapata@csic.es}

\author[unizar]{P. García-Navarro}
\ead{pigar@unizar.es}

\cortext[cor1]{Corresponding author}

\address[eead]{Soil and Water, EEAD / CSIC.
P.O. Box 13034, 50080~Zaragoza, Spain.}
\address[bifi]{BIFI: Instituto de Biocomputación y Física de Sistemas Complejos,
Universidad de Zaragoza.
Mariano Esquillor, Edificio I+D, 50009~Zaragoza, Spain.}
\address[kit]{Steinbuch Centre for Computing (SCC),
Karlsruhe Institute of Technology (KIT).
KIT-Campus Nord, Hermann von Helmholtzplatz 1, 76344 Eggenstein - Leopoldshafen,
Germany.}
\address[unizar]{Fluid Mechanics, LIFTEC, CSIC-Universidad de Zaragoza.
María de Luna 3, 50018~Zaragoza, Spain.}

\begin{keyword}
calibration, optimization, simulation, software, irrigation, sprinkler, furrow,
canal
\end{keyword}

\begin{abstract}
En este trabajo se presenta CALIBRATOR, a software program to perform
calibrations or optimization o empirical parameters. La sintaxis del programa es
lo suficientemente flexible para poder combinarlo con múltiples y variados
programas de simulación.
En el programa están implementados dos algoritmos de optimización de fuerza
bruta: sweeps and Monte-Carlo y un algoritmo genético.
El programa permite la ejecución paralelizada de manera sencilla en múltiples
computadoras y aprovechar los múltiples procesadores de cada computadora.
El manejo y las posibilidades de CALIBRATOR se analizan en cuatro aplicaciones
prácticas: optimización de manejo de canales y calibración de coeficientes
empíricos de modelos de riego por gravedad, del modelo balístico de riego por
aspersión y del movimiento de las máquinas de riego.
This software is open source source and is distributed with a BSD (Berkeley
Software Distribution) type license.
\end{abstract}

\maketitle

\section{Introduction}

CALIBRATOR \citep{CalibratorGit} is an open source software to perform
calibrations or optimizations of empirical parameters with a BSD type license.

\section{Methods}

\subsection{Sweep brutal force method}

El método de barrido divide el espacio entre los valores extremos de las
variables a optimizar en intervalos regulares y realiza una simulación para cada
una de las combinaciones de variables resultantes. Véase el esquema de un
ejemplo en la figura~\ref{FigSweep}. El número total de simulaciones que se
realizan es:
\EQ{N_{simulations}=x_{sweeps}\times y_{sweeps}\times\cdots,}{EqNSweeps}
siendo $x_{sweeps}$ el número de barridos en la variable $x$.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\multiput(50,40)(30,0){5}{\qbezier[40](0,0)(0,60)(0,120)}
	\multiput(50,40)(0,30){5}{\qbezier[40](0,0)(60,0)(120,0)}
	\multiput(50,40)(30,0){5}{\multiput(0,0)(0,30){5}{\circle*{2}}}
	\qbezier[10](50,10)(50,25)(50,40)
	\put(40,0){$x_{\min}$}
	\qbezier[10](170,10)(170,25)(170,40)
	\put(160,0){$x_{\max}$}
	\qbezier[10](20,40)(35,40)(50,40)
	\put(0,37){$y_{\min}$}
	\qbezier[10](20,160)(35,160)(50,160)
	\put(0,157){$y_{\max}$}
}{Diagram showing an example of application of the sweep brutal force method
with two variables for $x_{sweeps}=y_{sweeps}=5$}{FigSweep}

\subsection{Monte-Carlo method}

El método de Monte-Carlo realiza simulaciones con las variables a optimizar
obtenidas aleatoriamente con probabilidad uniforme en el rango comprendido entre
los valores extremos. En la figura~\ref{FigMonteCarlo} vemos el esquema de un
ejemplo con dos variables.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\put(59,159){\circle*{2}}
	\put(153,73){\circle*{2}}
	\put(98,67){\circle*{2}}
	\put(129,154){\circle*{2}}
	\put(128,104){\circle*{2}}
	\put(119,131){\circle*{2}}
	\put(136,77){\circle*{2}}
	\put(60,102){\circle*{2}}
	\put(87,97){\circle*{2}}
	\put(65,66){\circle*{2}}
	\put(80,43){\circle*{2}}
	\put(153,63){\circle*{2}}
	\put(147,109){\circle*{2}}
	\put(99,119){\circle*{2}}
	\put(61,107){\circle*{2}}
	\put(54,75){\circle*{2}}
	\put(117,47){\circle*{2}}
	\put(116,127){\circle*{2}}
	\put(51,125){\circle*{2}}
	\put(52,123){\circle*{2}}
	\put(100,55){\circle*{2}}
	\put(74,64){\circle*{2}}
	\put(55,49){\circle*{2}}
	\put(49,105){\circle*{2}}
	\put(146,75){\circle*{2}}	
	\qbezier[50](50,10)(50,85)(50,160)
	\put(40,0){$x_{\min}$}
	\qbezier[50](170,10)(170,85)(170,160)
	\put(160,0){$x_{\max}$}
	\qbezier[50](20,40)(95,40)(170,40)
	\put(0,37){$y_{\min}$}
	\qbezier[50](20,160)(95,160)(170,160)
	\put(0,157){$y_{\max}$}
}{Diagram illustrating a Monte-Carlo brutal force method with two variables and
$N_{simulations}=25$}{FigMonteCarlo}

\subsection{Iterative algorithm applied to brutal force methods}

CALIBRATOR allows to iterate both brutal force methods (sweep or Monte-Carlo) to
increase the convergence. In this case, the bests results of the previous
iteration are used to force new intervals in the variables. Then, para
$N_{bests}^j$ el subconjunto de las mejores simulaciones de la $j$-ésima
iteración, definimos las siguientes magnitudes:
\begin{description}
\item{$\displaystyle x_{\max}^b=\max_{i\in N_{bests}}x_i^j$}: máximo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\item{$\displaystyle x_{\min}^b=\max_{i\in N_{bests}}x_i^j$}: mínimo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\end{description}
El nuevo intervalo en la variable $x$ con el que se construirán las variables a
optimizar en la siguiente iteración estará comprendido entre:
\[
	x_{\max}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		+\left(x_{\max}^b-x_{\min}^b\right)(1+tol)}{2},
\]
\[
	x_{\min}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		-\left(x_{\max}^b-x_{\min}^b\right)(1+tol)}{2},
\]
\EQ{x_i^{j+1}\in\left[x_{\min}^{j+1},\;x_{\max}^{j+1}\right],}
{EqIterationInterval}
being $tol$ a tolerance increasing the size of the variable intervals to
simulate the next iteration.
En la figura~\ref{FigIterative} se ilustra un ejemplo del procedimiento con el
que el algoritmo iterativo modifica los intervalos de las variables para
incrementar la convergencia.

\PICTURE{210}{400}
{
	\small
	\multiput(0,0)(0,200){2}
	{
		\put(20,10){\vector(0,1){180}}
		\put(20,10){\vector(1,0){180}}
		\put(10,190){$y$}
		\put(200,0){$x$}
	}
	\put(90,380){1st iteration}
	\put(50,370){*: bests results}
	\put(59,359){\circle*{2}}
	\put(153,273){\circle*{2}}
	\put(98,267){*}
	\put(129,354){\circle*{2}}
	\put(128,304){*}
	\put(119,331){\circle*{2}}
	\put(136,277){\circle*{2}}
	\put(60,302){\circle*{2}}
	\put(87,297){*}
	\put(65,266){\circle*{2}}
	\put(80,243){\circle*{2}}
	\put(153,263){\circle*{2}}
	\put(147,309){\circle*{2}}
	\put(99,319){*}
	\put(61,307){\circle*{2}}
	\put(54,275){\circle*{2}}
	\put(117,247){\circle*{2}}
	\put(116,327){\circle*{2}}
	\put(51,325){\circle*{2}}
	\put(52,323){\circle*{2}}
	\put(100,255){\circle*{2}}
	\put(74,264){\circle*{2}}
	\put(55,249){\circle*{2}}
	\put(49,305){\circle*{2}}
	\put(146,275){\circle*{2}}	
	\qbezier[50](50,210)(50,285)(50,360)
	\put(40,200){$x_{\min}^1$}
	\qbezier[50](170,210)(170,285)(170,360)
	\put(160,200){$x_{\max}^1$}
	\qbezier[50](20,240)(95,240)(170,240)
	\put(0,237){$y_{\min}^1$}
	\qbezier[50](20,360)(95,360)(170,360)
	\put(0,357){$y_{\max}^1$}
	\qbezier[21](89,272)(109.5,272)(130,272)
	\qbezier[21](89,324)(109.5,324)(130,324)
	\qbezier[26](89,272)(89,298)(89,324)
	\qbezier[26](130,272)(130,298)(130,324)
	\put(89,267){\vector(1,0){41}}
	\put(130,267){\vector(-1,0){41}}
	\put(90,255){$x_{\max}^b-x_{\min}^b$}
	\put(84.9,215){\vector(1,0){49.2}}
	\put(134.1,215){\vector(-1,0){49.2}}
	\put(90,220){$x_{\max}^2-x_{\min}^2$}
	\qbezier[20](89,272)(86.95,241)(84.9,210)
	\qbezier[20](130,272)(132.05,241)(134.1,210)
	\qbezier[23](89,272)(54.5,269.4)(20,266.8)
	\qbezier[23](89,324)(54.5,326.6)(20,329.2)
	\put(80,180){2nd iteration}
	\put(92,123){\circle*{2}}
	\put(131,83){\circle*{2}}
	\put(108,80){\circle*{2}}
	\put(121,121){\circle*{2}}
	\put(121,97){\circle*{2}}
	\put(117,110){\circle*{2}}
	\put(124,84){\circle*{2}}
	\put(93,96){\circle*{2}}
	\put(104,94){\circle*{2}}
	\put(95,79){\circle*{2}}
	\put(101,68){\circle*{2}}
	\put(131,78){\circle*{2}}
	\put(129,100){\circle*{2}}
	\put(109,104){\circle*{2}}
	\put(93,98){\circle*{2}}
	\put(90,83){\circle*{2}}
	\put(116,70){\circle*{2}}
	\put(116,108){\circle*{2}}
	\put(89,107){\circle*{2}}
	\put(90,106){\circle*{2}}
	\put(109,74){\circle*{2}}
	\put(99,78){\circle*{2}}
	\put(91,71){\circle*{2}}
	\put(89,98){\circle*{2}}
	\put(128,83){\circle*{2}}
	\qbezier[40](84.9,10)(84.9,69.6)(84.9,129.2)
	\put(74.9,0){$x_{\min}^2$}
	\qbezier[40](134.1,10)(134.1,69.6)(134.1,129.2)
	\put(124.1,0){$x_{\max}^2$}
	\qbezier[35](20,129.2)(77.05,129.2)(134.1,129.2)
	\put(0,126.2){$y_{\max}^2$}
	\qbezier[35](20,66.8)(77.05,66.8)(134.1,66.8)
	\put(0,63.8){$y_{\min}^2$}
}{Diagram representing an example of the iterative algorithm applied to a
Monte-Carlo brutal force method with two variables for $N_{simulations}= 25$ and
two iterations}{FigIterative}

\subsection{Genetic method}

CALIBRATOR implementa el método genético GENETIC \citep{genetic} con sus
algoritmos por defecto. Los algoritmos están inspirados en \citet{gaul}, aunque
han sido completamente reescritos con muchas simplificaciones y haciendo uso de
modernas librerías externas. El código de GENETIC es también open source bajo
licencia de tipo BSD. En la figura~\ref{FigGeneticFlow} puede verse un diagrama
de flujo del funcionamiento del método genético implementado en GENETIC.

\psset{xunit=0.5mm,yunit=0.5mm}
\PSPICTURE{-120}{-185}{120}{20}
{
	\tiny
	\rput(0,15){Generation of $N_{population}$}
	\rput(0,10){random genomes}
	\psframe(-35,5)(35,20)
	\psline{->}(0,5)(0,0)
	\rput(0,-5){$generation=1$}
	\psframe(-25,-10)(25,0)
	\psline{->}(0,-10)(0,-15)
	\rput(0,-20){Simulation of the $N_{population}$}
	\rput(0,-25){entities}
	\psframe(-40,-30)(40,-15)
	\psline{->}(0,-30)(0,-35)
	\rput(0,-40){Sorting the $N_{population}$}
	\rput(0,-45){entities by objective function value}
	\psframe(-45,-50)(45,-35)
	\psline{->}(0,-50)(0,-55)
	\rput(0,-60){Elliminating the worst}
	\rput(0,-65){$N_{mutation}+N_{reproduction}+N_{adaptation}$ entities}
	\psframe(-65,-70)(65,-55)
	\psline{->}(0,-70)(-80,-75)
	\rput(-80,-80){Generation of $N_{mutation}$}
	\rput(-80,-85){new entities by mutation}
	\psframe(-115,-90)(-45,-75)
	\psline{->}(-80,-90)(-80,-95)
	\rput(-80,-100){Simulation of the $N_{mutation}$}
	\rput(-80,-105){new mutated entities}
	\psframe(-115,-110)(-45,-95)
	\psline{->}(0,-70)(0,-75)
	\rput(0,-80){Generation of $N_{reproduction}$}
	\rput(0,-85){new entities by reproduction}
	\psframe(-40,-90)(40,-75)
	\psline{->}(0,-90)(0,-95)
	\rput(0,-100){Simulation of the $N_{reproduction}$}
	\rput(0,-105){new reproduced entities}
	\psframe(-40,-110)(40,-95)
	\psline{->}(0,-70)(82.5,-75)
	\rput(82.5,-80){Generation of $N_{adaptation}$}
	\rput(82.5,-85){new entities by adaptation}
	\psframe(120,-90)(45,-75)
	\psline{->}(82.5,-90)(82.5,-95)
	\rput(82.5,-100){Simulation of the $N_{adaptation}$}
	\rput(82.5,-105){new adaptated entities}
	\psframe(120,-110)(45,-95)
	\psline{->}(-80,-110)(0,-115)
	\psline{->}(0,-110)(0,-115)
	\psline{->}(82.5,-110)(0,-115)
	\rput(0,-120){Sorting the old $N_{survival}$ entities and the new}
	\rput(0,-125){$N_{mutation}+N_{reproduction}+N_{adaptation}$ entities}
	\rput(0,-130){by objective function values}
	\psframe(-65,-115)(65,-135)
	\psline{->}(0,-135)(0,-140)
	\rput(0,-145){Increase $+1$ $generation$}
	\psframe(-30,-140)(30,-150)
	\psline{->}(0,-150)(0,-155)
	\rput(0,-162.5){$generation<N_{generations}$?}
	\pspolygon(-50,-162.5)(0,-170)(50,-162.5)(0,-155)
	\psline{->}(-50,-162.5)(-120,-162.5)(-120,-62.5)(-65,-62.5)
	\rput(-60,-160){Yes}
	\rput(-5,-172.5){No}
	\psline{->}(0,-170)(0,-175)
	\rput(0,-180){Select the best entity}
	\psframe(-30,-185)(30,-175)
}{Flow diagram of the genetic method implemented in GENETIC}{FigGeneticFlow}

\subsubsection{The genome}

Las variables a calibrar/optimizar se codifican en GENETIC en una cadena de bits
(genoma). Cuanto mayor sea el número de bits asignado a una variable mayor es la
precisión. El número de bits asignado a cada variable, y por tanto también el
tamaño del genoma, es fijo y es igual para todas las simulaciones. En la
figura~\ref{FigGenome} puede verse un diagrama de ejemplo de una codifición de 3
variables. El valor asignado a una variable $x$ viene determinado por los
valores extremos permitidos $x_{\min}$ y $x_{\max}$ por el número binario
asignado en el genoma a la variable $I_x$ y por el número de bits asignados a la
variable $N_x$ siguiendo la fórmula:
\EQ{x=x_{\min}+\frac{I_x}{2^{N_x}}\,\left(x_{\max}-x_{\min}\right).}{EqGenome}

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{30}
{
	\scriptsize
	\rput(40,27){Genome}
	\rput(15,23){Variable 1}
	\pspolygon(0,15)(30,15)(30,20)(0,20)
	\rput(40,23){Variable 2}
	\pspolygon(30,15)(50,15)(50,20)(30,20)
	\rput(65,23){Variable 3}
	\pspolygon(50,15)(80,15)(80,20)(50,20)
	\psline{->}(10,12)(0,12)
	\rput(5,9){Less}
	\rput(5,6){significative}
	\rput(5,3){bit}
	\psline{->}(20,12)(30,12)
	\rput(25,9){More}
	\rput(25,6){significative}
	\rput(25,3){bit}
	\rput(2,17.5){1}
	\rput(4,17.5){0}
	\rput(6,17.5){0}
	\rput(8,17.5){1}
	\rput(10,17.5){0}
	\rput(12,17.5){0}
	\rput(14,17.5){1}
	\rput(16,17.5){1}
	\rput(18,17.5){1}
	\rput(20,17.5){1}
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
}{Diagram illustrating an example codifying three variables to optimize into a
genome. First and third variables have been codified with 14 bits, and second
variable has been codified with 9 bits.}{FigGenome}

\subsubsection{Supervivencia de los mejores individuos}

Para una población de $N_{population}$ individuos, en la primera generación se
simulan todos los casos calculando las variables de entrada a partir del genoma
de cada individuo.

Después, en cada generación, se generarán $N_{population}\times R_{mutation}$
individuos por mutación, $N_{population}\times R_{reproduction}$ individuos
por reproducciónción y $N_{population}\times R_{adaptation}$ individuos
pos adaptación sustituyendo los individuos de la antigua población que
obtuvieron peores valores en la función de evaluación. Por tanto sobreviven los
$N_{survival}$ mejores individuos:
\EQ
{
	N_{survival}=N_{population}\times
	\left(1-R_{mutation}-R_{reproduction}-R_{adaptation}\right),
}{EqSurvival}
Los nuevos individuos se generarán por mutación, reproducción y adpatación de
los genomas de estos mejores individuos. Además, los ancestros a partir de los
que se generarán nuevos individuos se eligen entre la población superviviente,
CALIBRATOR utiliza el algoritmo de selección por defecto de GENETIC, que hace
una elección aleatoria con una probabilidad linealmente decreciente según su
ordinal en el conjunto ordenado de individuos supervivientes (véase la
figura~\ref{FigSelection}).

\PICTURE{250}{110}
{
	\put(10,20){\vector(0,1){80}}
	\put(10,20){\vector(1,0){235}}
	\put(0,102){Probability to be selected as parent}
	\put(0,0){Survival population sorted by objective function values}
	\multiput(20,20)(10,0){2}{\line(0,1){66}}
	\put(20,86){\line(1,0){10}}
	\put(17,10){1st}
	\multiput(40,20)(10,0){2}{\line(0,1){60}}
	\put(40,80){\line(1,0){10}}
	\put(37,10){2nd}
	\multiput(60,20)(10,0){2}{\line(0,1){54}}
	\put(60,74){\line(1,0){10}}
	\put(57,10){3rd}
	\multiput(80,20)(10,0){2}{\line(0,1){48}}
	\put(80,68){\line(1,0){10}}
	\put(77,10){4th}
	\multiput(100,20)(10,0){2}{\line(0,1){42}}
	\put(100,62){\line(1,0){10}}
	\put(97,10){...}
	\multiput(120,20)(10,0){2}{\line(0,1){36}}
	\put(120,56){\line(1,0){10}}
	\multiput(140,20)(10,0){2}{\line(0,1){30}}
	\put(140,50){\line(1,0){10}}
	\multiput(160,20)(10,0){2}{\line(0,1){24}}
	\put(160,44){\line(1,0){10}}
	\multiput(180,20)(10,0){2}{\line(0,1){18}}
	\put(180,38){\line(1,0){10}}
	\multiput(200,20)(10,0){2}{\line(0,1){12}}
	\put(200,32){\line(1,0){10}}
	\multiput(220,20)(10,0){2}{\line(0,1){6}}
	\put(220,26){\line(1,0){10}}
	\put(215,10){Last}
	\qbezier[54](10,90.5)(127.5,50.25)(245,20)
}{Graphic showing the probability of a survival entity to be selected as parent
of the new entities generated by mutation, reproduction or adaptation
algorithms}{FigSelection}

\subsubsection{Mutation algorithm}

En el algoritmo de mutación se realiza una copia idéntica del genoma del
progenitor pero con un bit invertido elegido aleatoriamente con probabilidad
uniforme. En la figura~\ref{FigMutation} puede verse un ejemplo ilustrando el
procedimiento.

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{20}
{
	\scriptsize
	\rput(10,17.5){Mother}
	\pspolygon(20,15)(80,15)(80,20)(20,20)
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(30,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(50,17.5){1}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(10,2.5){Soon}
	\pspolygon(20,0)(80,0)(80,5)(20,5)
	\rput(22,2.5){1}
	\rput(24,2.5){1}
	\rput(26,2.5){0}
	\rput(28,2.5){1}
	\rput(30,2.5){1}
	\rput(32,2.5){1}
	\rput(34,2.5){0}
	\rput(36,2.5){1}
	\rput(38,2.5){0}
	\rput(40,2.5){0}
	\rput(42,2.5){0}
	\rput(44,2.5){0}
	\rput(46,2.5){0}
	\rput(48,2.5){0}
	\rput(50,2.5){1}
	\rput(52,2.5){1}
	\rput(54,2.5){1}
	\rput(56,2.5){1}
	\rput(58,2.5){1}
	\rput(60,2.5){0}
	\rput(62,2.5){1}
	\rput(64,2.5){0}
	\rput(66,2.5){0}
	\rput(68,2.5){0}
	\rput(70,2.5){0}
	\rput(72,2.5){1}
	\rput(74,2.5){1}
	\rput(76,2.5){1}
	\rput(78,2.5){1}
	\psline{->}(50,15)(50,5)
	\rput(60,10){Mutation}
	\pspolygon(35,15)(37,15)(37,20)(35,20)
	\pspolygon(35,5)(37,5)(37,0)(35,0)
	\psline{->}(32,10)(36,10)(36,15)
	\psline{->}(32,10)(36,10)(36,5)
	\rput(16,10){Inversion of a random bit}
}{Diagram showing an example of the generation of a new entity by mutation}
{FigMutation}

\subsubsection{Reproduction algorithm}

En GENETIC el algoritmo por defecto, y usado en CALIBRATOR, selecciona 2
ancestros diferentes. Entonces genera un nuevo individuo haciendo una mezcla
aleatoria de los bits de los ancestros. El individuo generado tiene los mismos
bits que los ancestros donde el genoma es igual en ambos ancestros, y un bit
aleatorio en el resto. En la figura~\ref{FigReproduction} se representa un
esquema del algoritmo.

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{20}
{
	\scriptsize
	\multido{\rb=0+7.5,\rt=5+7.5}{3}
	{
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](20,\rb)(23,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](25,\rb)(29,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](45,\rb)(47,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](49,\rb)(51,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](59,\rb)(61,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](63,\rb)(67,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](71,\rb)(75,\rt)
	}
	\rput(10,17.5){Mother}
	\psframe(20,15)(80,20)
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(30,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(50,17.5){1}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(10,2.5){Father}
	\psframe(20,0)(80,5)
	\rput(22,2.5){1}
	\rput(24,2.5){0}
	\rput(26,2.5){0}
	\rput(28,2.5){1}
	\rput(30,2.5){0}
	\rput(32,2.5){0}
	\rput(34,2.5){1}
	\rput(36,2.5){1}
	\rput(38,2.5){1}
	\rput(40,2.5){1}
	\rput(42,2.5){1}
	\rput(44,2.5){1}
	\rput(46,2.5){0}
	\rput(48,2.5){1}
	\rput(50,2.5){1}
	\rput(52,2.5){0}
	\rput(54,2.5){0}
	\rput(56,2.5){0}
	\rput(58,2.5){0}
	\rput(60,2.5){0}
	\rput(62,2.5){0}
	\rput(64,2.5){0}
	\rput(66,2.5){0}
	\rput(68,2.5){1}
	\rput(70,2.5){1}
	\rput(72,2.5){1}
	\rput(74,2.5){1}
	\rput(76,2.5){0}
	\rput(78,2.5){0}
	\rput(10,10){Son}
	\psframe(20,7.5)(80,12.5)
	\rput(22,10){1}
	\rput(24,10){0}
	\rput(26,10){0}
	\rput(28,10){1}
	\rput(30,10){0}
	\rput(32,10){0}
	\rput(34,10){0}
	\rput(36,10){1}
	\rput(38,10){1}
	\rput(40,10){0}
	\rput(42,10){1}
	\rput(44,10){1}
	\rput(46,10){0}
	\rput(48,10){1}
	\rput(50,10){1}
	\rput(52,10){1}
	\rput(54,10){1}
	\rput(56,10){1}
	\rput(58,10){0}
	\rput(60,10){0}
	\rput(62,10){0}
	\rput(64,10){0}
	\rput(66,10){0}
	\rput(68,10){1}
	\rput(70,10){0}
	\rput(72,10){1}
	\rput(74,10){1}
	\rput(76,10){0}
	\rput(78,10){1}
	\psline{->}(50,5)(50,7.5)
	\psline{->}(50,15)(50,12.5)
	\psline{->}(10,5)(10,7.5)
	\psline{->}(10,15)(10,12.5)
}{Diagram illustrating an example of the generation of a new entitiy by
reproduction in the GENETIC default algorithm. Nótese que los bits iguales en
ambos ancestros (en gris en el diagrama) se mantienen en el hijo. El resto de 
los bits son aleatorios}{FigReproduction}

\subsubsection{Adaptation algorithm}

En GENETIC se implementa un algoritmo que se ha denominado "adaptación" aunque,
en el sentido biológico, es más bien una mutación "suave". El algoritmo
selecciona aleatoriamente con probabilidad uniforme una de las variables
codificadas en el genoma. Luego selecciona aleatoriamente un bit asignando una
probabilidad linealmente decreciente según sea más significativo este bit. El
nuevo individuo tiene una copia literal del genoma del ancestro con el bit
seleccionado invertido. En la figura~\ref{FigAdaptation} puede verse un diagrama
con un ejemplo.

\psset{unit=1mm}
\PSPICTURE{-30}{-7.5}{80}{30}
{
	\scriptsize
	\rput(-10,17.5){Mother}
	\rput(15,23){Variable 1}
	\psframe(0,15)(30,20)
	\rput(40,23){Variable 2}
	\psframe(30,15)(50,20)
	\rput(65,23){Variable 3}
	\psline{->}(55,28)(65,28)(65,26)
	\rput(35,28){Random selection of a variable}
	\psframe(55,21)(75,26)
	\psframe(50,15)(80,20)
	\psline{->}(10,12)(0,12)
	\rput(5,9){Less}
	\rput(5,6){significative}
	\rput(5,3){bit}
	\psline{->}(20,12)(30,12)
	\rput(25,9){More}
	\rput(25,6){significative}
	\rput(25,3){bit}
	\rput(2,17.5){1}
	\rput(4,17.5){0}
	\rput(6,17.5){0}
	\rput(8,17.5){1}
	\rput(10,17.5){0}
	\rput(12,17.5){0}
	\rput(14,17.5){1}
	\rput(16,17.5){1}
	\rput(18,17.5){1}
	\rput(20,17.5){1}
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(65,10){Probability of selection}
	\rput(65,7){of a bit}
	\psframe[fillcolor=gray,fillstyle=solid](77,0)(79,0.5)
	\psframe[fillcolor=gray,fillstyle=solid](75,0)(77,1.0)
	\psframe[fillcolor=gray,fillstyle=solid](73,0)(75,1.5)
	\psframe[fillcolor=gray,fillstyle=solid](71,0)(73,2.0)
	\psframe[fillcolor=gray,fillstyle=solid](69,0)(71,2.5)
	\psframe[fillcolor=gray,fillstyle=solid](67,0)(69,3.0)
	\psframe[fillcolor=gray,fillstyle=solid](65,0)(67,3.5)
	\psframe[fillcolor=gray,fillstyle=solid](63,0)(65,4.0)
	\psframe[fillcolor=gray,fillstyle=solid](61,0)(63,4.5)
	\psframe[fillcolor=gray,fillstyle=solid](59,0)(61,5.0)
	\psframe[fillcolor=gray,fillstyle=solid](57,0)(59,5.5)
	\psframe[fillcolor=gray,fillstyle=solid](55,0)(57,6.0)
	\psframe[fillcolor=gray,fillstyle=solid](53,0)(55,6.5)
	\psframe[fillcolor=gray,fillstyle=solid](51,0)(53,7.0)
	\rput(-10,-5){Son}
	\psframe(0,-2.5)(30,-7.5)
	\psframe(30,-2.5)(50,-7.5)
	\psframe(50,-2.5)(80,-7.5)
	\rput(2,-5){1}
	\rput(4,-5){0}
	\rput(6,-5){0}
	\rput(8,-5){1}
	\rput(10,-5){0}
	\rput(12,-5){0}
	\rput(14,-5){1}
	\rput(16,-5){1}
	\rput(18,-5){1}
	\rput(20,-5){1}
	\rput(22,-5){1}
	\rput(24,-5){1}
	\rput(26,-5){0}
	\rput(28,-5){1}
	\rput(32,-5){1}
	\rput(34,-5){0}
	\rput(36,-5){0}
	\rput(38,-5){0}
	\rput(40,-5){0}
	\rput(42,-5){0}
	\rput(44,-5){0}
	\rput(46,-5){0}
	\rput(48,-5){0}
	\rput(52,-5){1}
	\rput(54,-5){1}
	\rput(56,-5){0}
	\rput(58,-5){1}
	\rput(60,-5){0}
	\rput(62,-5){1}
	\rput(64,-5){0}
	\rput(66,-5){0}
	\rput(68,-5){0}
	\rput(70,-5){0}
	\rput(72,-5){1}
	\rput(74,-5){1}
	\rput(76,-5){1}
	\rput(78,-5){1}
	\psline{->}(-10,15)(-10,-2.5)
	\rput(-20,6.25){Adaptation}
	\psframe(55,-7.5)(57,-2.5)
	\psframe(55,15)(57,20)
}{Diagrama mostrando un ejemplo de la generación de un nuevo individuo a partir
de un ancestro por adaptación}{FigAdaptation}

Este algoritmo es muy similar al de mutación, descrito en una previa subsección
pero, puesto que tiene mayor probabilidad de afectar a bits menos
significativos, tiene mayor probabilidad de que los cambios sean pequeños.

\section{Implementation}

\subsection{External libraries}

CALIBRATOR hace uso de las siguientes librerías externas, todas ellas open
source:

\begin{itemize}
\item\citet{libxml}: librería requerida para leer el fichero de entrada que usa
	el formato XML.
\item\citet{gsl}: librería científica requerida para generar los números
	pseudo-aleatorios que usan los algoritmos genético y de Monte-Carlo.
\item\citet{glib}: librería requerida para implementar algunos tipos de datos,
	to parse the input file templates y las tareas con las que el programa
	paraleliza el uso de los múltiples procesadores de la máquina.
\item\citet{openmpi,mpich}: librerías opcionales. En el caso de estar alguna de
	ellas instaladas en el sistema, el programa la utiliza para permitir el uso
	paralelizado en múltiples máquinas.
\end{itemize}

\subsection{Building the executable file from the source code}

El código fuente de CALIBRATOR está escrito en lenguaje C. This software has
been built and tested in the following operative systems:
\begin{itemize}
\item Debian Linux 7.7,
\item Debian kFreeBSD 7.7,
\item DragonFly BSD 3.8.2,
\item FreeBSD 10.0,
\item NetBSD 6.1.5,
\item OpenBSD 5.6,
\item Windows XP\footnotemark[1],
\item and Window 7\footnotemark[1].
\footnotetext[1]{Windows XP and Windows 7 are trademarks of Microsoft
Corporation.}
\end{itemize}
Probabily, this software can be built and works in other operative systems,
software distributions or versions but it has not been tested.

Para poder crear el fichero ejecutable a partir del código fuente debe tener
instalado en el sistema un compilador de C (\citet{gcc} or \citet{clang}), los
sistemas de configuración \citet{autoconf} y \citet{automake}, el programa de
control de creación de ejecutables \citet{gnumake} y las librerías externas
descritas en la subsección anterior. En sistemas Microsoft Windows pueden
seguirse las instrucciones dadas en \citet{mingw-make} para instalar todas estas
utilidades.

Una vez instaladas todas las herramientas, debe descargarse el código fuente de
GENETIC y compilarse en una terminal ejecutando:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ cd PATH_TO_GENETIC/0.6.0
$ aclocal
$ autoconf
$ automake --add-missing
$ ./configure
$ make
\end{lstlisting}

Después, debe descargarse el código fuente de CALIBRATOR, enlazarse con GENETIC
y compilarse ejecutando en una terminal:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ cd PATH_TO_CALIBRATOR/0.2.3
$ ln -s PATH_TO_GENETIC/0.6.0 genetic
$ aclocal
$ autoconf
$ automake --add-missing
$ ./configure
$ make
\end{lstlisting}

Algunos sistemas (as Microsoft Windows 64 bits or OpenBSD) pueden requerir
instrucciones u opciones extras, consultar los README files de ambos
repositorios.

\subsection{Command line format}

\begin{itemize}

\item Command line in sequential mode (where X is the number of threads to
execute):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item Command line in parallelized mode (where X is the number of threads to
open in every node):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ mpirun [MPI options] ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item The sintaxis of the simulator has to be:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./simulator_name input_file_1 [input_file_2] [...] output_file
\end{lstlisting}
They are two options for the ouput file. It can begin with a number indicating
the objective function value or it can be a results file that has to be
evaluated by an external program (the evaluator) comparing with an experimental
file.

\item In the last option of the former point, the sintaxis of the program to
evaluate the objetive function has to be (where the results file has to begin
with the objective function value):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./evaluator_name simulated_file experimental_file results_file
\end{lstlisting}

\end{itemize}

\subsubsection{Input data file}

The format of the input data file is:
\begin{lstlisting}[language=xml,basicstyle=\scriptsize]
<?xml version="1.0"/>
<calibrate simulator="simulator_name" evaluator="evaluator_name"
	algorithm="algorithm_type" simulations="simulations_number"
	iterations="iterations_number" tolerance="tolerance_value"
	bests="bests_number">
	<experiment name="data_file_1" template1="template_1_1"
		template2="template_1_2" .../>
	...
	<experiment name="data_file_N" template1="template_N_1"
		template2="template_N_2" .../>
	<variable name="variable_1" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
	...
	<variable name="variable_M" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
</calibrate>
\end{lstlisting}

The main XML node has to begin with the key label \emph{"calibrate"}. The
available fields are:
\begin{description}
\item{simulator}: to indicate the simulator program.
\item{evaluator}: optional. It specify the evaluator program if required.
\item{algorithm}: to set the optimization algorithm. Three value are available:
	\begin{description}
	\item{sweep}: sweep brutal force algorithm. Requires on each variable:
		\begin{description}
		\item{sweeps}: number of sweeps to generate on each variable in every
			experiment.
		\end{description}
	\item{Monte-Carlo}: Monte-Carlo brutal force algorithm. Requires on the main
		XML node:
		\begin{description}
		\item{simulations}: number of simulations to run on each iteration in
			every experiment.
		\end{description}
	\item{genetic}: genetic algorithm. Requires the following parameters in the
		main XML node:
		\begin{description}
		\item{population}: number of population entities.
		\item{generations}: number of generations.
		\item{mutation}: mutation ratio.
		\item{reproduction}: reproduction ratio.
		\item{adaptation}: adaptation ratio.
		\end{description}
	And on each variable:
		\begin{description}
		\item{bits}: number of bits to encode each variable.
		\end{description}
	\end{description}
\item{iterations}: number of iterations (default 1) to perform the iterative
algorithm. It applies only on sweep and Monte-Carlo methods.
\item{bests}: number of bests simulations to calculate convergence interval on
next iteration for the iterative algorithm (default 1). It applies only on
sweep and Monte-Carlo methods.
\item{tolerance}: tolerance parameter to relax convergence interval of the
iterative algoritm (default 0). It applies only on sweep and Monte-Carlo
methods.
\end{description}

The first type of child XML nodes has to begin with the key label
\emph{"experiment"}. It details the experimental data and it has the fields:
\begin{description}
\item{name}: name of the input data file with experimental results to calibrate.
\item{templateX}: $X$-th input data file template for the simulation program.
\end{description}

The second type of child XML nodes has to begin with the key label
\emph{"variable"}. It specifies the variables data and it has the fields:
\begin{description}
\item{name}: variable label. On the $X$-th variable, the program parse all input
file templates creating the input simulation files by substituying all
@variableX@ labels by this name.
\item{minimum, maximum}: variable extreme values. The program creates the input
simulation files by substituying all @valueX@ labels in the input file templates
by a value between these extreme values on the $X$-th variable, depending on
optimization algorithm.
\item{absolute\_minimum, absolute\_maximum}: absolute variable extreme values.
On iterative methods, the tolerance can increase initial \emph{minimum} or
\emph{maximum} values in each iteration. These values are the extreme values
allowed to prevent to exceed the model parameter limits.
\item{format}: standard C-format string to set the format to save the variable
in the simulation input files.
\end{description}

\section{Practical applications}

A continuación vamos a exponer unos casos de apliación práctica de CALIBRATOR en
combinación con muy diferentes programas para calibrar u optimizar coeficientes
en modelos tan diferentes como riego por superficie, flujo en canales, aspersión
o movimiento de máquinas de riego.

\subsection{Optimization of a canal management}

A real irrigation channel has been analysed in order to find out the optimal values of two
variables of interest which take into account the daily gate modification time, being performed
in a scenario of modernization to sprinkler irrigation.

The area of study is located in the northeast of Spain, in the province of Huesca. It consists of
the first 13657 meters of the Canal de Violada. This canal was built and designed in the 1930s, 
but due to severe infiltration problems, the initial stretch of the canal (13353 m) was rebuilt at 
the beginning of the 21st century. Canal de Violada is supplied by the Canal de Monegros and the studied 
stretch was designed for a maximum discharge of 6 $m^3 \cdot s^{-1}$. This stretch delivers water to three irrigation 
communities: Almudévar, Gurrea and El Temple. 

Two sections can be distinguished in this work, the new stretch and the last 304 meters. Both share the 
same bottom slope, $S_0$ = 0.00059 and differ in the cross section dimensions and the value of the Gauckler-Manning 
roughness coefficient, having a value of 0.014 and 0.02 $m^{-1/3}\cdot s$ for the first and the final stretch 
respectively. These values correspond to polished and coarse concrete \citet{Chow59}.

Two key optimization variables have been studied: $d_A$ and $d_{GT}$. Where $d_A$ takes into account the delay between 
the modification time of the inlet discharge and the modification time in the Almudévar gate and $d_{GT}$ takes into account 
the delay between the inlet and Gurrea and Temple gates modification.

The canal was initially dry and it was waited until a stationary state with a discharge of 2 $m^{-1/3}\cdot s$ was reached. 
The objective of this work was to provide the required daily discharge to the three important irrigation gates together 
with keeping a constant discharge of 2 $m^{-1/3}\cdot s$ at the outlet gate. 

The required discharge in every gate for a modernization scenario to sprinkler irrigation was obtained after an elaborate 
field analysis. As a brief explanation, taking into account the crops distribution, soil water retention properties, 
characteristics of the parcels and hydrants, the electricity tariffs depending on the hour of the day and the design of a 
reservoir in the area, seven different scenarios were obtained as a function of the historical irrigation requirements for 
the same period using real data \citet{Zapata09}.


\subsection{Calibration of empirical parameters on surface irrigation}

Se ha usado CALIBRATOR para obtener los parámetros empíricos de los modelos de
fricción, difusión e infiltración de unos experimentos publicados en
\citet{JaviSurcos2} y que van a ser simulado con el programa SURCOS
\citep{Surcos,SurcosGit,JaviSurcos3}. Consisten en cuatro casos de riego en
surcos con difusión de soluto. Los surcos tenían una longitud de $100$ m y se simularon con una malla de 100 celdas. Los surcos eran contiguos y se prepararon
con la misma geometría. Además se realizaron casi simultáneamente, de forma que
se puede asumir que el suelo presentaba idénticas propiedades.

Se han utilizado el modelo de fricción de Manning y el de infiltración de
Kostiakov-Lewis. Estos modelos requieren la calibración de tres coeficientes
empíricos: el número de Manning $n$ y los coeficientes del modelo de
infiltración $K$ y $a$. En el artículo original se usó un método de calibración
de fuerza bruta con 3000  imulaciones, considerando que en cada una de estas
simulaciones comprende el cálculo de los cuatro experimentos descritos en el
paper. En este trabajo se han utilizado el mismo de simulaciones con varios de
los métodos de calibración implementados en CALIBRATOR. Ejecutar las 3000
simulaciones, paralelizadas en cuatro tareas para aprovechar al máximo el doble
núcleo con hyperthreading del procesador, costó aproximadamente 1h20m en un
laptop computer equipado con un procesador Intel(R) Core(TM) i7 M620 2.67GHz.

En la tabla~\ref{TabSurcos} se muestran los resultados obtenidos de los
coeficientes óptimos y del valor de la función de evaluación,
donde se ha usado la misma norma de error descrita en \citet{JaviSurcos2}. Los
resultados son muy similares entre los diferentes métodos y también muy
similares a los del artículo original. Esto es debido a que se forma una región
relativamente extensa de combinaciones de los parámetros empíricos que producen
valores muy similares de la función objetivo, no permitiendo una obtención
precisa de los valores óptimos. No obstante, puede comprobarse como tanto el
método iterativo como los genéticos obtienen mejores resultados que el método de
fuerza de bruta de Monte-Carlo sin iteraciones con el mismo número total de
simulaciones.

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	\multirow{3}{*}{Monte-Carlo} & $N_{simulations}=3000$
	& $n=0.0395$
	& \multirow{3}{*}{0.3430} \\
	& $N_{iterations}=1$ & $K=7.861\cdot 10^{-4}$
	\\ & & $a=0.534$
	\\ \hline
	\multirow{4}{*}{Monte-Carlo} & $N_{simulations}=500$
	& $n=0.0422$
	& \multirow{4}{*}{0.3321} \\
	& $N_{iterations}=6$ & $K=9.994\cdot 10^{-4}$
	\\ & $N_{bests}=10$ & $a=0.497$
	\\ & $tol=0.2$
	\\ \hline
	\multirow{5}{*}{genetic} & $N_{population}=750$
	& $n=0.0425$
	& \multirow{5}{*}{0.3327}
	\\ & $N_{generations}=6$ & $K=9.856\cdot 10^{-4}$
	\\ & $R_{mutation}=0.2$ & $a=0.497$
	\\ & $R_{reproduction}=0.2$
	\\ & $R_{adaptation}=0.2$
	\\ \hline
	\multirow{5}{*}{genetic} & $N_{population}=300$
	& $n=0.0425$
	& \multirow{5}{*}{0.3327}
	\\ & $N_{generations}=31$ & $K=9.856\cdot 10^{-4}$
	\\ & $R_{mutation}=0.1$ & $a=0.497$
	\\ & $R_{reproduction}=0.1$
	\\ & $R_{adaptation}=0.1$
	\\ \hline
}{Parámetros empíricos óptimos y valor de la función objetivo obtenido para el
experimento de riego por surcos descrito en \citet{JaviSurcos2} usando el
programa SURCOS y varios algoritmos de optimización implementados en CALIBRATOR
con el mismo número total de simulaciones}{TabSurcos}

En la figura~\ref{FigSurcos} se muestran los resultados de la simulación, con
los coeficientes obtenidos por el método de Monte-Carlo con $N_{iterations}=6$,
frente a las medidas experimentales.

\FIGVI{surcos-advance.eps}{surcos-depth.eps}{surcos-solute-q1.eps}
{surcos-solute-q2.eps}{surcos-solute-q3.eps}{surcos-solute-q4.eps}
{
	(a) Advance time profile, (b) inlet depth evolution and (c-f) solute
	concentration evolution at probes for the experiments Q1-Q4 described in
	\citet{JaviSurcos2} simulated with the optime calibrated parameters obtained
	for the Monte-Carlo method with $N_{iterartions}=6$ (see
	table~\ref{TabSurcos})
}{FigSurcos}

\subsection{Calibration of empirical parameters of the balistic model on
sprinkler irrigation}

El modelo balístico \citep{Fukui80,Playan06} es el más utilizado para
caracterizar el comportamiento de los aspersores en riego por aspersión. En este
modelo se considera que las gotas emitidas son aproximadamente esféricas y se
comportan como un proyectil esférico que se mueve por la atmósfera sufriendo la
fuerza de gravedad y la de resistencia aerodinámica. En este modelo ser requiere
conocer la velocidad inicial de las gotas emitidas. En la mayoría de modelos de aspersores, el chorro inicial es lo suficientemente compacto como para poder
considerar que todas las gotas emitidas salen de la boquilla con la misma
velocidad inicial. Ésta puede obtenerse tanto midiendo la presión en el aspersor
y aplicando Bernouilli como midiendo el caudal emitido y dividiendo por la
sección de la boquilla. Los otros datos que se requieren para calcular el
reparto del agua son los que caracterizan la distribución de tamaños de gotas
emitidas. En el modelo utilizado, descrito en \citet{Playan06}, esta
distribución se caracteriza con dos parámetros $D_{50}$ y $n$. Además, para
caracterizar efectos aerodinámicos del chorro, en presencia de viento el modelo
utiliza otros dos coeficientes de corrección de la resistencia aerodinámica:
$k_1$ y $k_2$.
Por lo tanto el modelo se calibra en dos pasos: en un primero se ajustan los
coeficientes $D_{50}$ y $n$ que ajustan la pluviometría recogida en condiciones
sin viento y se consideran propios de cada modelo de aspersión a una presión
determinada. En un segundo paso se calibran los coeficientes $k_1$ y $k_2$ que
mejor ajustan las pluviometrías medidas para cada velocidad de viento.

En este trabajo vamos a calibrar un modelo de aspersor de tipo spray, el N44
fabricado por Senninger, a una presión de trabajo de 20PSI. En este tipo de
aspersores, el chorro impacta con un plato fijo surcado de acanaladuras. Para
determinar la velocidad inicial de salida de las gotas tras el impacto con el
plato se recurrió a la técnica fotográfica descrita en \citet{Salvador09}. Con
esta técnica se determinó que la pérdida de carga en el impacto con el plato era
del 50\%.

\subsection{Calibration of empirical parameters of the movement of a sprinkler
center-pivot}

El movimiento de las torres de un center-pivot sigue un movimiento caótico que
depende del movimiento de la torre exterior, de los ángulos de arranque y parada
en las torres y de las velocidades de arranque y parada. En \citet{Ouazaa14} se
propuso un modelo pretendiendo simular la distribución de marchas y paradas de
cada una de las torres y se desarrollaron varios experimentos en los que se
midieron estas distribuciones en el funcionamiento de un center-pivot real en
campo. La torre exterior es la que gobierna el movimiento, funcionando con un
régimen de arranques y paradas que depende del tiempo de ciclo y del porcentaje
de funcionamiento ambos ajustables para que la máquina haga el riego deseado.
El resto de las torres hace un régimen de arranques y paradas en el que la
entrada en marcha o parada de la torre responde a que se sobrepasen ángulos
máximos o mínimos en las juntas de las tuberías (véase un diagrama en la
figura~\ref{FigPivotDiagram}). Este movimiento es bastante caótico debido a una
cierta incertidumbre en los ángulos de parada y marcha.

\psset{unit=1mm}
\PSPICTURE{-10}{-6}{93}{20}
{
	\rput(25,17){$\alpha_i<\alpha_{start}\;\Rightarrow\;T_i$ start}
	\rput(65,17){$\alpha_i>\alpha_{stop}\;\Rightarrow\;T_i$ stop}
	\psarc{->}(0,0){93}{0}{7}
	\psline(0,0)(20,0)(40,1)(60,2.5)(90,5.5)
	\pscircle*(20,0){0.5}
	\pscircle*(40,1){0.5}
	\pscircle*(60,2.5){0.5}
	\pscircle*(80,4.5){0.5}
	\pscircle*(0,0){1.0}
	\rput(0,-3){Centre}
	\rput(20,-3){$T_1$}
	\rput(40,-2){$T_2$}
	\rput(60,-0.5){$T_3$}
	\rput(80,1.5){$T_4$}
	\psarc(20,0){3}{2.86}{180}
	\psarc(40,1){3}{4.29}{177.14}
	\psarc(60,2.5){3}{5.71}{175.71}
	\rput(20,6){$\alpha_1$}
	\rput(40,7){$\alpha_2$}
	\rput(60,8.5){$\alpha_3$}
}{Diagram illustrating the movement of a centre-pivot irrigation machine with
four towers}{FigPivotDiagram}

En este trabajo, vamos a simular un pivot de cuatro torres separadas 50.11 m. La
velocidad lineal máxima de cada torre se midió experimentalmente resultando:
$v_1=0.02738$ m/s, $v_2=0.02824$ m/s, $v_3=0.03008$ m/s y $v_4=0.03753$ m/s.
La torre exterior lleva una velocidad considerablemente superior porque soporta
menos peso y por tanto sufre menor rozamiento. En el modelo hay que calibrar
cuatro parámetros empíricos: los ángulos medios de arranque
$\overline{\alpha_{start}}$ y parada $\overline{\alpha_{stop}}$, la
incertidumbre en estos ángulos $\delta$ y el tiempo de arranque y parada $\tau$.
En cada ciclo de movimiento de cada torre, los ángulos de arranque y parada se
obtienen como:
\EQ
{
	\alpha_{start}=\overline{\alpha_{start}}+(r-0.5)\,\delta,\quad
	\alpha_{stop}=\overline{\alpha_{stop}}+(r-0.5)\,\delta,
}{EqPivotStartStop}
con $r$ un número aleatorio definido con probabilidad uniforme en el rango
$r\in[0,1)$. Los tiempos de arranque y parada resultantes de cada torre se
midieron en cuatro experimentos de un día de duración con el pivot trabajando en
ciclos de 71 segundos al 100\%, 52\%, 42\% y 27.48\%. Estos tiempos se agruparon
en cuatro respectivos histogramas y definimos la función objetivo a minimizar
como el mean square error que se produce entre los histogramas simulados y los
medidos.

\psset{unit=1mm}
\PSPICTURE{-16}{-6}{75}{39}
{
	\scriptsize
	\psline{->}(0,0)(0,30)
	\psline{->}(0,0)(70,0)
	\rput(0,36){Tower}
	\rput(0,32){linear velocity}
	\rput(70,-3){Time}
	\psline(0,0)(10,0)(15,20)(25,20)(30,0)(45,0)(50,20)(60,20)(65,0)
	\rput(-8,22){Maximum}
	\rput(-8,18){velocity}
	\psline[linestyle=dotted](0,20)(15,20)
	\psline{<->}(10,23)(15,23)
	\rput(12.5,26){$\tau$}
	\psline{<->}(10,29)(30,29)
	\rput(20,35){Start}
	\rput(20,32){time}
	\psline{<->}(25,23)(30,23)
	\rput(27.5,26){$\tau$}
	\psline{<->}(30,23)(45,23)
	\rput(37.5,29){Stop}
	\rput(37.5,26){time}
}{Linear velocity of a centre-pivot tower on starts and stops}{FigPivotVelocity}

En la tabla~\ref{TabPivot} se muestran algunos de los resultados obtenidos con
un total de 10000 simulaciones de cada uno de los cuatro experimentos, que
costaron aproximadamente 50 minutos paralelizadas en cuatro tareas en el mismo
laptop computer usado en las anteriores subsecciones.

\TABLE{\scriptsize}{cccc}
{
	Optimization & Optimization & Optime empirical & Objective function
	\\ algorithm & parameters & parameters & value
	\\ \hline
	\multirow{4}{*}{Sweep} & $N_{simulations}=10000$
	& $\overline{\alpha_{start}}=179.370^\circ$
	& \multirow{4}{*}{12327.19}
	\\ & $N_{iterations}=1$ & $\overline{\alpha_{stop}}=180.330^\circ$
	\\ & & $\delta=0.270^\circ$
	\\ & & $\tau=1.70$s
	\\ \hline
	\multirow{4}{*}{Sweep} & $N_{simulations}=625$
	& $\overline{\alpha_{start}}=179.395^\circ$
	& \multirow{4}{*}{12326.04} \\
	& $N_{iterations}=16$ & $\overline{\alpha_{stop}}=180.313^\circ$
	\\ & $N_{bests}=10$ & $\delta=0.257^\circ$
	\\ & $tol=0.25$ & $\tau=3.42$s
	\\ \hline
	\multirow{4}{*}{Monte-Carlo} & $N_{simulations}=625$
	& $\overline{\alpha_{start}}=179.37^\circ$
	& \multirow{4}{*}{12327.19} \\
	& $N_{iterations}=16$ & $\overline{\alpha_{stop}}=180.33^\circ$
	\\ & $N_{bests}=10$ & $\delta=0.27^\circ$
	\\ & $tol=0.25$ & $\tau=1.7$s
	\\ \hline
	\multirow{5}{*}{genetic} & $N_{population}=1000$
	& $\overline{\alpha_{start}}=179.37^\circ$
	& \multirow{5}{*}{0.3327}
	\\ & $N_{generations}=16$ & $\overline{\alpha_{stop}}=180.33^\circ$
	\\ & $R_{mutation}=0.2$ & $\delta=0.27^\circ$
	\\ & $R_{reproduction}=0.2$ & $\tau=1.7$s
	\\ & $R_{adaptation}=0.2$
	\\ \hline
	\multirow{5}{*}{genetic} & $N_{population}=400$
	& $\overline{\alpha_{start}}=179.37^\circ$
	& \multirow{5}{*}{0.3327}
	\\ & $N_{generations}=81$ & $\overline{\alpha_{stop}}=180.33^\circ$
	\\ & $R_{mutation}=0.1$ & $\delta=0.27^\circ$
	\\ & $R_{reproduction}=0.1$ & $\tau=1.7$s
	\\ & $R_{adaptation}=0.1$
	\\ \hline
}{Parámetros empíricos óptimos y valor de la función objetivo obtenido para el
pivot de cuatro torres descrito en \citet{Ouazaa14} usando varios algoritmos de
optimización implementados en CALIBRATOR con el mismo número total de
simulaciones}{TabPivot}

\section{Conclusions}

En este trabajo se ha presentado CALIBRATOR, un nuevo programa de software para
calibración y optimización de coeficientes empíricos de diferentes modelos de
cálculo. Este programa implementa dos modelos clásicos de fuerza bruta, el de
barrido y el de Monte-Carlo, a los que incorpora un algoritmo iterativo para
mejorar la convergencia. Además CALIBRATOR permite utilizar el método genético
por defecto implementado en GENETIC.

Este programa permite la ejecución eficiente, aprovechando al máximo los
múltiples procesadores de las máquinas y pudiendo utilizarse de forma sencilla
en múltiples máquinas en paralelo, logrando una gran capacidad y velocidad de
cómputo e independizando los modelos físicos de los algoritmos de optimización,
calibración y paralelización.

CALIBRATOR ha mostrado ser un programa muy flexible y versátil que permite
calibrar y optimizar muy variados problemas de modelización adaptándose a la
sintaxis de programas muy diferentes. En este trabajo CALIBRATOR ha sido
utilizado con éxito en aplicaciones prácticas de ingeniería agraria tan diversas
como optimización de manejo de canales y calibración de coeficientes empíricos
de un modelo de riego por surcos, de un modelo balístico de riego por aspersión
y de un modelo de movimiento de máquinas de riego.

\section*{References}
\bibliography{bib}

\end{document}

