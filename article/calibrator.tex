\documentclass[review,authoryear]{elsarticle}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{pstricks}
\usepackage{multido}

\usepackage{lineno}
\linenumbers

\newcommand{\EQ}[2]
{\begin{equation}#1\end{equation}\label{#2}}

\newcommand{\PICTURE}[5]
{
	\begin{figure}[ht!]
		\centering
		\begin{picture}(#1,#2)
			#3
		\end{picture}
		\caption{#4.\label{#5}}
	\end{figure}
}

\newcommand{\PSPICTURE}[7]
{
	\begin{figure}[ht!]
		\centering
		\pspicture(#1,#2)(#3,#4)
			#5
		\endpspicture
		\caption{#6.\label{#7}}
	\end{figure}
}

\title{CALIBRATOR: a software to perform calibrations or optimizations of
empirical parameters}

\author{J. Burguete, B. Latorre, S. Ambroj, A. Lacasta, S. Ouazaa,
P. García-Navarro}
 
\bibliographystyle{elsarticle-harv}

\begin{document}

\maketitle

\section{Introduction}

CALIBRATOR \cite{CalibratorGit} is an open source software to perform
calibrations or optimizations of empirical parameters with a BSD (Berkeley
Software Distribution) type license.

\section{Methods}

\subsection{Sweep brutal force method}

El método de barrido divide el espacio entre los valores extremos de las
variables en intervalos regulares y realiza una simulación para cada una de las
combinaciones de variables resultantes. Véase un esquema en la
figura~\ref{FigSweep}. El número total de simulaciones que realiza es:
\EQ{N_{simulations}=x_{sweeps}\times y_{sweeps}\times\cdots,}{EqNSweeps}
siendo $x_{sweeps}$ el número de barridos en la variable $x$.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\multiput(50,40)(30,0){5}{\qbezier[40](0,0)(0,60)(0,120)}
	\multiput(50,40)(0,30){5}{\qbezier[40](0,0)(60,0)(120,0)}
	\multiput(50,40)(30,0){5}{\multiput(0,0)(0,30){5}{\circle*{2}}}
	\qbezier[10](50,10)(50,25)(50,40)
	\put(40,0){$x_{\min}$}
	\qbezier[10](170,10)(170,25)(170,40)
	\put(160,0){$x_{\max}$}
	\qbezier[10](20,40)(35,40)(50,40)
	\put(0,37){$y_{\min}$}
	\qbezier[10](20,160)(35,160)(50,160)
	\put(0,157){$y_{\max}$}
}{Diagram showing an example of application of the sweep brutal force method
with two variables for $x_{sweeps}=y_{sweeps}=5$}{FigSweep}

\subsection{Monte-Carlo method}

El método de Monte-Carlo realiza simulaciones de variables obtenidas
aleatoriamente con probabilidad uniforme en el rango comprendido entre los
valores extremos. En la figura~\ref{FigMonteCarlo} vemos el esquema de un
ejemplo con dos variables.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\put(59,159){\circle*{2}}
	\put(153,73){\circle*{2}}
	\put(98,67){\circle*{2}}
	\put(129,154){\circle*{2}}
	\put(128,104){\circle*{2}}
	\put(119,131){\circle*{2}}
	\put(136,77){\circle*{2}}
	\put(60,102){\circle*{2}}
	\put(87,97){\circle*{2}}
	\put(65,66){\circle*{2}}
	\put(80,43){\circle*{2}}
	\put(153,63){\circle*{2}}
	\put(147,109){\circle*{2}}
	\put(99,119){\circle*{2}}
	\put(61,107){\circle*{2}}
	\put(54,75){\circle*{2}}
	\put(117,47){\circle*{2}}
	\put(116,127){\circle*{2}}
	\put(51,125){\circle*{2}}
	\put(52,123){\circle*{2}}
	\put(100,55){\circle*{2}}
	\put(74,64){\circle*{2}}
	\put(55,49){\circle*{2}}
	\put(49,105){\circle*{2}}
	\put(146,75){\circle*{2}}	
	\qbezier[50](50,10)(50,85)(50,160)
	\put(40,0){$x_{\min}$}
	\qbezier[50](170,10)(170,85)(170,160)
	\put(160,0){$x_{\max}$}
	\qbezier[50](20,40)(95,40)(170,40)
	\put(0,37){$y_{\min}$}
	\qbezier[50](20,160)(95,160)(170,160)
	\put(0,157){$y_{\max}$}
}{Diagram illustrating a Monte-Carlo brutal force method with two variables and
$N_{simulations}=25$}{FigMonteCarlo}

\subsection{Iterative algorithm applied to brutal force methods}

CALIBRATOR allows to iterate both brutal force methods (sweep or Monte-Carlo) to
increase the convergence. In this case, the bests results of the previous
iteration are used to force new intervals in the variables. Then, para
$N_{bests}^j$ el subconjunto de las mejores simulaciones de la $j$-ésima
iteración, definimos las siguientes magnitudes:
\begin{description}
\item{$\displaystyle x_{\max}^b=\max_{i\in N_{bests}}x_i^j$}: máximo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\item{$\displaystyle x_{\min}^b=\max_{i\in N_{bests}}x_i^j$}: mínimo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\end{description}
El nuevo intervalo en la variable $x$ en el que se simulará la siguiente
iteración estará comprendido entre:
\[
	x_{\max}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		+\left(x_{\max}^b-x_{\min}^b\right)(1+tol)}{2},
\]
\[
	x_{\min}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		-\left(x_{\max}^b-x_{\min}^b\right)(1+tol)}{2},
\]
\EQ{x_i^{j+1}\in\left[x_{\min}^{j+1},\;x_{\max}^{j+1}\right],}
{EqIterationInterval}
being $tol$ a tolerance increasing the size of the variable intervals to
simulate the next iteration.
En la figura~\ref{FigIterative} se ilustra el procedimiento con el que el
algoritmo iterativo modifica los intervalos de las variables para incrementar la
convergencia.

\PICTURE{210}{400}
{
	\small
	\multiput(0,0)(0,200){2}
	{
		\put(20,10){\vector(0,1){180}}
		\put(20,10){\vector(1,0){180}}
		\put(10,190){$y$}
		\put(200,0){$x$}
	}
	\put(90,380){1st iteration}
	\put(50,370){*: bests results}
	\put(59,359){\circle*{2}}
	\put(153,273){\circle*{2}}
	\put(98,267){*}
	\put(129,354){\circle*{2}}
	\put(128,304){*}
	\put(119,331){\circle*{2}}
	\put(136,277){\circle*{2}}
	\put(60,302){\circle*{2}}
	\put(87,297){*}
	\put(65,266){\circle*{2}}
	\put(80,243){\circle*{2}}
	\put(153,263){\circle*{2}}
	\put(147,309){\circle*{2}}
	\put(99,319){*}
	\put(61,307){\circle*{2}}
	\put(54,275){\circle*{2}}
	\put(117,247){\circle*{2}}
	\put(116,327){\circle*{2}}
	\put(51,325){\circle*{2}}
	\put(52,323){\circle*{2}}
	\put(100,255){\circle*{2}}
	\put(74,264){\circle*{2}}
	\put(55,249){\circle*{2}}
	\put(49,305){\circle*{2}}
	\put(146,275){\circle*{2}}	
	\qbezier[50](50,210)(50,285)(50,360)
	\put(40,200){$x_{\min}^1$}
	\qbezier[50](170,210)(170,285)(170,360)
	\put(160,200){$x_{\max}^1$}
	\qbezier[50](20,240)(95,240)(170,240)
	\put(0,237){$y_{\min}^1$}
	\qbezier[50](20,360)(95,360)(170,360)
	\put(0,357){$y_{\max}^1$}
	\qbezier[21](89,272)(109.5,272)(130,272)
	\qbezier[21](89,324)(109.5,324)(130,324)
	\qbezier[26](89,272)(89,298)(89,324)
	\qbezier[26](130,272)(130,298)(130,324)
	\put(89,267){\vector(1,0){41}}
	\put(130,267){\vector(-1,0){41}}
	\put(90,255){$x_{\max}^b-x_{\min}^b$}
	\put(84.9,215){\vector(1,0){49.2}}
	\put(134.1,215){\vector(-1,0){49.2}}
	\put(90,220){$x_{\max}^2-x_{\min}^2$}
	\qbezier[20](89,272)(86.95,241)(84.9,210)
	\qbezier[20](130,272)(132.05,241)(134.1,210)
	\qbezier[23](89,272)(54.5,269.4)(20,266.8)
	\qbezier[23](89,324)(54.5,326.6)(20,329.2)
	\put(80,180){2nd iteration}
	\put(92,123){\circle*{2}}
	\put(131,83){\circle*{2}}
	\put(108,80){\circle*{2}}
	\put(121,121){\circle*{2}}
	\put(121,97){\circle*{2}}
	\put(117,110){\circle*{2}}
	\put(124,84){\circle*{2}}
	\put(93,96){\circle*{2}}
	\put(104,94){\circle*{2}}
	\put(95,79){\circle*{2}}
	\put(101,68){\circle*{2}}
	\put(131,78){\circle*{2}}
	\put(129,100){\circle*{2}}
	\put(109,104){\circle*{2}}
	\put(93,98){\circle*{2}}
	\put(90,83){\circle*{2}}
	\put(116,70){\circle*{2}}
	\put(116,108){\circle*{2}}
	\put(89,107){\circle*{2}}
	\put(90,106){\circle*{2}}
	\put(109,74){\circle*{2}}
	\put(99,78){\circle*{2}}
	\put(91,71){\circle*{2}}
	\put(89,98){\circle*{2}}
	\put(128,83){\circle*{2}}
	\qbezier[40](84.9,10)(84.9,69.6)(84.9,129.2)
	\put(74.9,0){$x_{\min}^2$}
	\qbezier[40](134.1,10)(134.1,69.6)(134.1,129.2)
	\put(124.1,0){$x_{\max}^2$}
	\qbezier[35](20,129.2)(77.05,129.2)(134.1,129.2)
	\put(0,126.2){$y_{\max}^2$}
	\qbezier[35](20,66.8)(77.05,66.8)(134.1,66.8)
	\put(0,63.8){$y_{\min}^2$}
}{Diagram representing an example of the iterative algorithm applied to a
Monte-Carlo brutal force method with two variables for $N_{simulations}= 25$ and
two iterations}{FigIterative}

\subsection{Genetic method}

CALIBRATOR implementa el método genético GENETIC \cite{genetic} con sus
algoritmos por defecto. Los algoritmos están inspirados en \cite{gaul}, aunque
han sido completamente reescritos con muchas simplificaciones y haciendo uso de
modernas librerías externas. El código de GENETIC es también open source bajo
licencia de tipo BSD. En la figura~\ref{FigGeneticFlow} puede verse un diagrama
de flujo del funcionamiento del método genético implementado en GENETIC.

\psset{xunit=0.47mm,yunit=0.5mm}
\PSPICTURE{-130}{-200}{125}{20}
{
	\tiny
	\rput(0,12.5){$generation=1$}
	\pspolygon(-65,5)(65,5)(65,20)(-65,20)
	\psline{->}(0,5)(0,0)
	\rput(0,-5){Generation of $N_{population}$}
	\rput(0,-10){random genomes}
	\pspolygon(-65,-15)(65,-15)(65,0)(-65,0)
	\psline{->}(0,-15)(0,-20)
	\rput(0,-25){Simulation of the $N_{population}$}
	\rput(0,-30){entities}
	\pspolygon(-65,-35)(65,-35)(65,-20)(-65,-20)
	\psline{->}(0,-35)(0,-40)
	\rput(0,-45){Sorting the $N_{population}$}
	\rput(0,-50){entities by objective function value}
	\pspolygon(-65,-55)(65,-55)(65,-40)(-65,-40)
	\psline{->}(0,-55)(0,-60)
	\rput(0,-65){Elliminating the worst}
	\rput(0,-70){$N_{mutation}+N_{reproduction}+N_{adaptation}$ entities}
	\pspolygon(-65,-75)(65,-75)(65,-60)(-65,-60)
	\psline{->}(0,-75)(-90,-80)
	\rput(-85,-85){Generation of $N_{mutation}$}
	\rput(-85,-90){new entities by mutation}
	\pspolygon(-125,-95)(-45,-95)(-45,-80)(-125,-80)
	\psline{->}(-90,-95)(-90,-100)
	\rput(-85,-105){Simulation of the $N_{mutation}$}
	\rput(-85,-110){new mutated entities}
	\pspolygon(-125,-115)(-45,-115)(-45,-100)(-125,-100)
	\psline{->}(0,-75)(0,-80)
	\rput(0,-85){Generation of $N_{reproduction}$}
	\rput(0,-90){new entities by reproduction}
	\pspolygon(-40,-95)(40,-95)(40,-80)(-40,-80)
	\psline{->}(0,-95)(0,-100)
	\rput(0,-105){Simulation of the $N_{reproduction}$}
	\rput(0,-110){new reproduced entities}
	\pspolygon(-40,-115)(40,-115)(40,-100)(-40,-100)
	\psline{->}(0,-75)(90,-80)
	\rput(85,-85){Generation of $N_{adaptation}$}
	\rput(85,-90){new entities by adaptation}
	\pspolygon(125,-95)(45,-95)(45,-80)(125,-80)
	\psline{->}(90,-95)(90,-100)
	\rput(85,-105){Simulation of the $N_{adatation}$}
	\rput(85,-110){new adaptated entities}
	\pspolygon(125,-115)(45,-115)(45,-100)(125,-100)
	\psline{->}(-90,-115)(0,-120)
	\psline{->}(0,-115)(0,-120)
	\psline{->}(90,-115)(0,-120)
	\rput(0,-125){Sorting the old $N_{survival}$ entities and the new}
	\rput(0,-130){$N_{mutation}+N_{reproduction}+N_{adaptation}$ entities}
	\rput(0,-135){by objective function values}
	\pspolygon(-65,-120)(65,-120)(65,-140)(-65,-140)
	\psline{->}(0,-140)(0,-145)
	\rput(0,-152.5){Increase $+1$ $generation$}
	\pspolygon(-65,-145)(65,-145)(65,-160)(-65,-160)
	\psline{->}(0,-160)(0,-165)
	\rput(0,-172.5){$generation<N_{generations}$?}
	\pspolygon(-65,-172.5)(0,-180)(65,-172.5)(0,-165)
	\psline{->}(-65,-172.5)(-130,-172.5)(-130,-67.5)(-65,-67.5)
	\rput(-70,-170){Yes}
	\rput(-5,-182.5){No}
	\psline{->}(0,-180)(0,-185)
	\rput(0,-192.5){Select the best entity}
	\pspolygon(-65,-200)(65,-200)(65,-185)(-65,-185)
}{Flow diagram of the genetic method implemented in GENETIC}{FigGeneticFlow}

\subsubsection{The genome}

Las variables a calibrar/optimizar se codifican en GENETIC en una cadena de bits
(genoma). Cuanto mayor sea el número de bits asignado a una variable mayor es la
precisión. El número de bits asignado a cada variable, y por tanto también el
tamaño del genoma, es fijo y es igual para todas las simulaciones. En la
figura~\ref{FigGenome} puede verse un ejemplo de una codifición de 3 variables,
la primera y la tercera se han codificado con 14 bits y la segunda con 9 bits.
El valor asignado a una variable $x$ viene determinado por los valores extremos
permitidos $x_{\min}$ y $x_{\max}$ por el número binario asignado en el genoma a
la variable $I_x$ y por el número de bits asignados a la variable $N_x$
siguiendo la fórmula:
\EQ{x=x_{\min}+\frac{I_x}{2^{N_x}}\,\left(x_{\max}-x_{\min}\right).}{EqGenome}

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{30}
{
	\scriptsize
	\rput(40,27){Genome}
	\rput(15,23){Variable 1}
	\pspolygon(0,15)(30,15)(30,20)(0,20)
	\rput(40,23){Variable 2}
	\pspolygon(30,15)(50,15)(50,20)(30,20)
	\rput(65,23){Variable 3}
	\pspolygon(50,15)(80,15)(80,20)(50,20)
	\psline{->}(10,12)(0,12)
	\rput(5,9){Less}
	\rput(5,6){significative}
	\rput(5,3){bit}
	\psline{->}(20,12)(30,12)
	\rput(25,9){More}
	\rput(25,6){significative}
	\rput(25,3){bit}
	\rput(2,17.5){1}
	\rput(4,17.5){0}
	\rput(6,17.5){0}
	\rput(8,17.5){1}
	\rput(10,17.5){0}
	\rput(12,17.5){0}
	\rput(14,17.5){1}
	\rput(16,17.5){1}
	\rput(18,17.5){1}
	\rput(20,17.5){1}
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
}{An example codifying three variables to optimize into a genome}{FigGenome}

\subsubsection{Supervivencia de los mejores individuos}


Para una población de $N$ individuos, en la primera generación se
simulan $N_{population}$ casos calculando las variables de entrada a partir del
genoma de cada individuo.

Después, en cada generación, se generarán $N_{population}\times R_{mutation}$
individuos por mutación, $N_{population}\times R_{reproduction}$ individuos
por reproducciónción y $N_{population}\times R_{adaptation}$ individuos
pos adaptación sustituyendo los individuos de la antigua población que
obtuvieron peores valores en la función de evaluación. Por tanto sobreviven los
$N_{survival}$ mejores individuos:
\EQ
{
	N_{survival}=N_{population}\times
	\left(1-R_{mutation}-R_{reproduction}-R_{adaptation}\right),
}{EqSurvival}
Los nuevos individuos se generarán por mutación, reproducción y adpatación de
los genomas de estos mejores individuos. Además, los ancestros a partir de los
que se generarán nuevos individuos se eliben entre la población superviviente,
CALIBRATOR utiliza el algoritmo de selección por defecto de GENETIC, que hace
una elección aleatoria con una probabilidad linealmente decreciente según su
ordinal en el conjunto ordenado de individuos supervivientes (véase la
figura~\ref{FigSelection}.

\PICTURE{250}{110}
{
	\put(10,20){\vector(0,1){80}}
	\put(10,20){\vector(1,0){235}}
	\put(0,102){Probability to be selected as parent}
	\put(0,0){Survival population sorted by objective function values}
	\multiput(20,20)(10,0){2}{\line(0,1){66}}
	\put(20,86){\line(1,0){10}}
	\put(17,10){1st}
	\multiput(40,20)(10,0){2}{\line(0,1){60}}
	\put(40,80){\line(1,0){10}}
	\put(37,10){2nd}
	\multiput(60,20)(10,0){2}{\line(0,1){54}}
	\put(60,74){\line(1,0){10}}
	\put(57,10){3rd}
	\multiput(80,20)(10,0){2}{\line(0,1){48}}
	\put(80,68){\line(1,0){10}}
	\put(77,10){4th}
	\multiput(100,20)(10,0){2}{\line(0,1){42}}
	\put(100,62){\line(1,0){10}}
	\put(97,10){...}
	\multiput(120,20)(10,0){2}{\line(0,1){36}}
	\put(120,56){\line(1,0){10}}
	\multiput(140,20)(10,0){2}{\line(0,1){30}}
	\put(140,50){\line(1,0){10}}
	\multiput(160,20)(10,0){2}{\line(0,1){24}}
	\put(160,44){\line(1,0){10}}
	\multiput(180,20)(10,0){2}{\line(0,1){18}}
	\put(180,38){\line(1,0){10}}
	\multiput(200,20)(10,0){2}{\line(0,1){12}}
	\put(200,32){\line(1,0){10}}
	\multiput(220,20)(10,0){2}{\line(0,1){6}}
	\put(220,26){\line(1,0){10}}
	\put(215,10){Last}
	\qbezier[54](10,90.5)(127.5,50.25)(245,20)
}{Graphic showing the probability of a survival entity to be selected as parent
of the new entities generated by mutation, reproduction or adaptation
algorithms}{FigSelection}

\subsubsection{Mutation algorithm}

En el algoritmo de mutación se realiza una copia idéntica del genoma del
progenitor pero con un bit invertido elegido aleatoriamente con probabilidad
uniforme. En la figura~\ref{FigMutation} puede verse un ejemplo ilustrando el
procedimiento.

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{20}
{
	\scriptsize
	\rput(10,17.5){Mother}
	\pspolygon(20,15)(80,15)(80,20)(20,20)
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(30,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(50,17.5){1}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(10,2.5){Soon}
	\pspolygon(20,0)(80,0)(80,5)(20,5)
	\rput(22,2.5){1}
	\rput(24,2.5){1}
	\rput(26,2.5){0}
	\rput(28,2.5){1}
	\rput(30,2.5){1}
	\rput(32,2.5){1}
	\rput(34,2.5){0}
	\rput(36,2.5){1}
	\rput(38,2.5){0}
	\rput(40,2.5){0}
	\rput(42,2.5){0}
	\rput(44,2.5){0}
	\rput(46,2.5){0}
	\rput(48,2.5){0}
	\rput(50,2.5){1}
	\rput(52,2.5){1}
	\rput(54,2.5){1}
	\rput(56,2.5){1}
	\rput(58,2.5){1}
	\rput(60,2.5){0}
	\rput(62,2.5){1}
	\rput(64,2.5){0}
	\rput(66,2.5){0}
	\rput(68,2.5){0}
	\rput(70,2.5){0}
	\rput(72,2.5){1}
	\rput(74,2.5){1}
	\rput(76,2.5){1}
	\rput(78,2.5){1}
	\psline{->}(50,15)(50,5)
	\rput(60,10){Mutation}
	\pspolygon(35,15)(37,15)(37,20)(35,20)
	\pspolygon(35,5)(37,5)(37,0)(35,0)
	\psline{->}(32,10)(36,10)(36,15)
	\psline{->}(32,10)(36,10)(36,5)
	\rput(16,10){Inversion of a random bit}
}{Diagram showing an example of the generation of a new entity by mutation}
{FigMutation}

\subsubsection{Reproduction algorithm}

En GENETIC el algoritmo por defecto, y usado en CALIBRATOR, selecciona 2
ancestros diferentes. Entonces genera un nuevo individuo haciendo una mezcla
aleatoria de los bits de los ancestros. El individuo generado tiene los mismos
bits que los ancestros donde el genoma es igual en ambos ancestros, y un bit
aleatorio en el resto. En la figura~\ref{FigReproduction} se representa un
esquema del algoritmo.

\psset{unit=1mm}
\PSPICTURE{0}{0}{80}{20}
{
	\scriptsize
	\multido{\rb=0+7.5,\rt=5+7.5}{3}
	{
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](20,\rb)(23,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](25,\rb)(29,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](45,\rb)(47,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](49,\rb)(51,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](59,\rb)(61,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](63,\rb)(67,\rt)
		\psframe[linecolor=gray,fillcolor=gray,fillstyle=solid](71,\rb)(75,\rt)
	}
	\rput(10,17.5){Mother}
	\psframe(20,15)(80,20)
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(30,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(50,17.5){1}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(10,2.5){Father}
	\psframe(20,0)(80,5)
	\rput(22,2.5){1}
	\rput(24,2.5){0}
	\rput(26,2.5){0}
	\rput(28,2.5){1}
	\rput(30,2.5){0}
	\rput(32,2.5){0}
	\rput(34,2.5){1}
	\rput(36,2.5){1}
	\rput(38,2.5){1}
	\rput(40,2.5){1}
	\rput(42,2.5){1}
	\rput(44,2.5){1}
	\rput(46,2.5){0}
	\rput(48,2.5){1}
	\rput(50,2.5){1}
	\rput(52,2.5){0}
	\rput(54,2.5){0}
	\rput(56,2.5){0}
	\rput(58,2.5){0}
	\rput(60,2.5){0}
	\rput(62,2.5){0}
	\rput(64,2.5){0}
	\rput(66,2.5){0}
	\rput(68,2.5){1}
	\rput(70,2.5){1}
	\rput(72,2.5){1}
	\rput(74,2.5){1}
	\rput(76,2.5){0}
	\rput(78,2.5){0}
	\rput(10,10){Son}
	\psframe(20,7.5)(80,12.5)
	\rput(22,10){1}
	\rput(24,10){0}
	\rput(26,10){0}
	\rput(28,10){1}
	\rput(30,10){0}
	\rput(32,10){0}
	\rput(34,10){0}
	\rput(36,10){1}
	\rput(38,10){1}
	\rput(40,10){0}
	\rput(42,10){1}
	\rput(44,10){1}
	\rput(46,10){0}
	\rput(48,10){1}
	\rput(50,10){1}
	\rput(52,10){1}
	\rput(54,10){1}
	\rput(56,10){1}
	\rput(58,10){0}
	\rput(60,10){0}
	\rput(62,10){0}
	\rput(64,10){0}
	\rput(66,10){0}
	\rput(68,10){1}
	\rput(70,10){0}
	\rput(72,10){1}
	\rput(74,10){1}
	\rput(76,10){0}
	\rput(78,10){1}
	\psline{->}(50,5)(50,7.5)
	\psline{->}(50,15)(50,12.5)
	\psline{->}(10,5)(10,7.5)
	\psline{->}(10,15)(10,12.5)
}{Diagram illustrating an example of the generation of a new entitiy by
reproduction in the GENETIC default algorithm. Nótese que los bits iguales en
ambos ancestros (en gris en el diagrama) se mantienen en el hijo. El resto de 
los bits son aleatorios}{FigReproduction}

\subsubsection{Adaptation algorithm}

En GENETIC se implementa un algoritmo que se ha denominado "adaptación" aunque,
en el sentido biológico, es más bien una mutación "suave". El algoritmo
selecciona aleatoriamente con probabilidad uniforme una de las variables
codificadas en el genoma. Luego selecciona aleatoriamente un bit asignando una
probabilidad linealmente decreciente según sea más significativo este bit. El
nuevo individuo tiene una copia literal del genoma del ancestro con el bit
seleccionado invertido. En la figura~\ref{FigAdaptation} puede verse un diagrama
con un ejemplo.

\psset{unit=1mm}
\PSPICTURE{-30}{-7.5}{80}{30}
{
	\scriptsize
	\rput(-10,17.5){Mother}
	\rput(15,23){Variable 1}
	\psframe(0,15)(30,20)
	\rput(40,23){Variable 2}
	\psframe(30,15)(50,20)
	\rput(65,23){Variable 3}
	\psline{->}(55,28)(65,28)(65,26)
	\rput(35,28){Random selection of a variable}
	\psframe(55,21)(75,26)
	\psframe(50,15)(80,20)
	\psline{->}(10,12)(0,12)
	\rput(5,9){Less}
	\rput(5,6){significative}
	\rput(5,3){bit}
	\psline{->}(20,12)(30,12)
	\rput(25,9){More}
	\rput(25,6){significative}
	\rput(25,3){bit}
	\rput(2,17.5){1}
	\rput(4,17.5){0}
	\rput(6,17.5){0}
	\rput(8,17.5){1}
	\rput(10,17.5){0}
	\rput(12,17.5){0}
	\rput(14,17.5){1}
	\rput(16,17.5){1}
	\rput(18,17.5){1}
	\rput(20,17.5){1}
	\rput(22,17.5){1}
	\rput(24,17.5){1}
	\rput(26,17.5){0}
	\rput(28,17.5){1}
	\rput(32,17.5){1}
	\rput(34,17.5){0}
	\rput(36,17.5){0}
	\rput(38,17.5){0}
	\rput(40,17.5){0}
	\rput(42,17.5){0}
	\rput(44,17.5){0}
	\rput(46,17.5){0}
	\rput(48,17.5){0}
	\rput(52,17.5){1}
	\rput(54,17.5){1}
	\rput(56,17.5){1}
	\rput(58,17.5){1}
	\rput(60,17.5){0}
	\rput(62,17.5){1}
	\rput(64,17.5){0}
	\rput(66,17.5){0}
	\rput(68,17.5){0}
	\rput(70,17.5){0}
	\rput(72,17.5){1}
	\rput(74,17.5){1}
	\rput(76,17.5){1}
	\rput(78,17.5){1}
	\rput(65,10){Probability of selection}
	\psframe[fillcolor=gray,fillstyle=solid](77,0)(79,0.5)
	\psframe[fillcolor=gray,fillstyle=solid](75,0)(77,1.0)
	\psframe[fillcolor=gray,fillstyle=solid](73,0)(75,1.5)
	\psframe[fillcolor=gray,fillstyle=solid](71,0)(73,2.0)
	\psframe[fillcolor=gray,fillstyle=solid](69,0)(71,2.5)
	\psframe[fillcolor=gray,fillstyle=solid](67,0)(69,3.0)
	\psframe[fillcolor=gray,fillstyle=solid](65,0)(67,3.5)
	\psframe[fillcolor=gray,fillstyle=solid](63,0)(65,4.0)
	\psframe[fillcolor=gray,fillstyle=solid](61,0)(63,4.5)
	\psframe[fillcolor=gray,fillstyle=solid](59,0)(61,5.0)
	\psframe[fillcolor=gray,fillstyle=solid](57,0)(59,5.5)
	\psframe[fillcolor=gray,fillstyle=solid](55,0)(57,6.0)
	\psframe[fillcolor=gray,fillstyle=solid](53,0)(55,6.5)
	\psframe[fillcolor=gray,fillstyle=solid](51,0)(53,7.0)
	\rput(-10,-5){Son}
	\psframe(0,-2.5)(30,-7.5)
	\psframe(30,-2.5)(50,-7.5)
	\psframe(50,-2.5)(80,-7.5)
	\rput(2,-5){1}
	\rput(4,-5){0}
	\rput(6,-5){0}
	\rput(8,-5){1}
	\rput(10,-5){0}
	\rput(12,-5){0}
	\rput(14,-5){1}
	\rput(16,-5){1}
	\rput(18,-5){1}
	\rput(20,-5){1}
	\rput(22,-5){1}
	\rput(24,-5){1}
	\rput(26,-5){0}
	\rput(28,-5){1}
	\rput(32,-5){1}
	\rput(34,-5){0}
	\rput(36,-5){0}
	\rput(38,-5){0}
	\rput(40,-5){0}
	\rput(42,-5){0}
	\rput(44,-5){0}
	\rput(46,-5){0}
	\rput(48,-5){0}
	\rput(52,-5){1}
	\rput(54,-5){1}
	\rput(56,-5){0}
	\rput(58,-5){1}
	\rput(60,-5){0}
	\rput(62,-5){1}
	\rput(64,-5){0}
	\rput(66,-5){0}
	\rput(68,-5){0}
	\rput(70,-5){0}
	\rput(72,-5){1}
	\rput(74,-5){1}
	\rput(76,-5){1}
	\rput(78,-5){1}
	\psline{->}(-10,15)(-10,-2.5)
	\rput(-20,6.25){Adaptation}
	\psframe(55,-7.5)(57,-2.5)
	\psframe(55,15)(57,20)
}{Diagrama mostrando un ejemplo de la generación de un nuevo individuo a partir
de un ancestro por adaptación}{FigAdaptation}

Este algoritmo es muy similar al de mutación, descrito en una previa subsección
pero, puesto que tiene mayor probabilidad de afectar a bits menos
significativos, tiene mayor probabilidad de hacer pequeños cambios.

\section{Implementation}

\subsection{External libraries}

CALIBRATOR hace uso de las siguientes librerías externas:

\begin{itemize}
\item\cite{libxml}: librería open source requerida para leer el fichero
	de entrada que usa el formato XML.
\item\cite{gsl}: librería científica open source requerida para generar
	los números pseudo-aleatorios que usan los algoritmos genético y de
	Monte-Carlo.
\item\cite{glib}: librería open source requerida para implementar algunos
	tipos de datos y las tareas con las que el programa paraleliza el uso de los
	múltiples procesadores de la máquina.
\item\cite{openmpi,mpich}: librerías open source opcionales. En
	el caso de estar alguna de ellas instaladas en el sistema, el programa la
	utiliza para permitir el uso paralelizado en múltiple máquinas.
\end{itemize}

\subsection{Building the executable file from the source code}

El código fuente de CALIBRATOR está escrito en lenguaje C. Para poder crear el
fichero ejecutable a partir del código fuente debe tener instalado en el sistema
un compilador de C (\cite{gcc} or \cite{clang}), el sistema de configuración
\cite{automake}, el programa de control de creación de ejecutables
\cite{gnumake} y las librerías externas descritas en la subsección anterior. En
sistemas de Microsoft Windows pueden seguirse las instrucciones dadas en
\cite{mingw-make}.

Una vez instaladas todas las herramientas debe descargarse el código fuente de
GENETIC y compilarse en una terminal ejecutando:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ cd PATH_TO_GENETIC/0.6.0
$ aclocal
$ autoconf
$ automake --add-missing
$ ./configure
$ make
\end{lstlisting}

Entonces debe descargarse el código fuente de CALIBRATOR, enlazarse con GENETIC
y compilarse ejecutando en una terminal:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ cd PATH_TO_CALIBRATOR/0.2.3
$ ln -s PATH_TO_GENETIC/0.6.0 genetic
$ aclocal
$ autoconf
$ automake --add-missing
$ ./configure
$ make
\end{lstlisting}

Algunos sistemas (as Microsoft Windows 64 bits or OpenBSD) pueden requerir
instrucciones u opciones extras, consultar los README files de ambos
repositorios.

\subsection{Command line format}

\begin{itemize}

\item Command line in sequential mode (where X is the number of threads to
execute):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item Command line in parallelized mode (where X is the number of threads to
open in every node):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ mpirun [MPI options] ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item The sintaxis of the simulator has to be:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./simulator_name input_file_1 [input_file_2] [...] output_file
\end{lstlisting}
They are two options for the ouput file. It can begin with a number indicating
the objective function value or it can be a results file that has to be
evaluated by an external program (the evaluator) comparing with an experimental
file.

\item In the last option of the former point, the sintaxis of the program to
evaluate the objetive function has to be (where the results file has to begin
with the objective function value):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./evaluator_name simulated_file experimental_file results_file
\end{lstlisting}

\end{itemize}

\subsubsection{Input data file}

The format of the input data file is:
\begin{lstlisting}[language=xml,basicstyle=\scriptsize]
<?xml version="1.0"/>
<calibrate simulator="simulator_name" evaluator="evaluator_name"
	algorithm="algorithm_type" simulations="simulations_number"
	iterations="iterations_number" tolerance="tolerance_value"
	bests="bests_number">
	<experiment name="data_file_1" template1="template_1_1"
		template2="template_1_2" .../>
	...
	<experiment name="data_file_N" template1="template_N_1"
		template2="template_N_2" .../>
	<variable name="variable_1" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
	...
	<variable name="variable_M" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
</calibrate>
\end{lstlisting}

The main XML node has to begin with key label "calibrate". The available fields
are:
\begin{description}
\item{simulator}: to indicate the simulator program.
\item{evaluator}: optional. It specify the evaluator program if required.
\item{algorithm}: to set the optimization algorithm. Three value are available:
	\begin{description}
	\item{sweep}: sweep brutal force algorithm. Requires on each variable:
		\begin{description}
		\item{sweeps}: number of sweeps to generate on each variable in every
			experiment.
		\end{description}
	\item{Monte-Carlo}: Monte-Carlo brutal force algorithm. Requires on the main
		XML node:
		\begin{description}
		\item{simulations}: number of simulations to run on each iteration in
			every experiment.
		\end{description}
	\item{genetic}: genetic algorithm. Requires the following parameters in the
		main XML node:
		\begin{description}
		\item{population}: number of population entities.
		\item{generations}: number of generations.
		\item{mutation}: mutation ratio.
		\item{reproduction}: reproduction ratio.
		\item{adaptation}: adaptation ratio.
		\end{description}
	And on each variable:
		\begin{description}
		\item{bits}: number of bits to encode each variable.
		\end{description}
	\end{description}
\item{iterations}: number of iterations (default 1) to perform the iterative
algorithm. It applies only on sweep and Monte-Carlo methods.
\item{bests}: number of bests simulations to calculate convergence interval on
next iteration (default 1). It applies only on iterative algorithm.
\item{tolerance}: tolerance parameter to increase convergence interval (default
0). It applies only on iterative algorithm.
\end{description}

\section{Practical applications}

\subsection{Calibration of empirical parameters on surface irrigation}

Se ha usado CALIBRATOR para obtener los parámetros empíricos de los modelos de
fricción, difusión e infiltración de un experimento publicado en
\cite{JaviSurcos2} que va a ser simulado con el programa SURCOS
\cite{Surcos,SurcosGit,JaviSurcos3}.

\subsection{Optimization of a canal management}

\subsection{Calibration of empirical parameters on sprinkler irrigation}

\section{Conclusions}

\section*{References}
\bibliography{bib}

\end{document}

