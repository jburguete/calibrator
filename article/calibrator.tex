\documentclass[review,authoryear]{elsarticle}

\usepackage[utf8]{inputenc}
\usepackage{listings}

\usepackage{lineno}
\linenumbers

\newcommand{\EQ}[2]
{\begin{equation}#1\end{equation}\label{#2}}

\newcommand{\PICTURE}[5]
{
	\begin{figure}[ht!]
		\centering
		\begin{picture}(#1,#2)
			#3
		\end{picture}
		\caption{#4.\label{#5}}
	\end{figure}
}

\title{CALIBRATOR: a software to perform calibrations or optimizations of
empirical parameters}

\author{J. Burguete, B. Latorre, S. Ambroj, A. Lacasta, S. Ouazaa,
P. García-Navarro}
 
\bibliographystyle{elsarticle-harv}

\begin{document}

\maketitle

\section{Introduction}

CALIBRATOR \cite{CalibratorGit} is an open source software to perform
calibrations or optimizations of empirical parameters with a BSD (Berkeley
Software Distribution) type license.

\section{Methods}

\subsection{Sweep brutal force method}

El método de barrido divide el espacio entre los valores extremos de las
variables en intervalos regulares y realiza una simulación para cada una de las
combinaciones de variables resultantes. Véase un esquema en la
figura~\ref{FigSweep}. El número total de simulaciones que realiza es:
\EQ{N_{simulations}=x_{sweeps}\times y_{sweeps}\times\cdots,}{EqNSweeps}
siendo $x_{sweeps}$ el número de barridos en la variable $x$.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\multiput(50,40)(30,0){5}{\qbezier[40](0,0)(0,60)(0,120)}
	\multiput(50,40)(0,30){5}{\qbezier[40](0,0)(60,0)(120,0)}
	\multiput(50,40)(30,0){5}{\multiput(0,0)(0,30){5}{\circle*{2}}}
	\qbezier[10](50,10)(50,25)(50,40)
	\put(40,0){$x_{\min}$}
	\qbezier[10](170,10)(170,25)(170,40)
	\put(160,0){$x_{\max}$}
	\qbezier[10](20,40)(35,40)(50,40)
	\put(0,37){$y_{\min}$}
	\qbezier[10](20,160)(35,160)(50,160)
	\put(0,157){$y_{\max}$}
}{Sweep brutal force method with two variables}{FigSweep}

\subsection{Monte-Carlo method}

El método de Monte-Carlo realiza simulaciones de variables obtenidas
aleatoriamente con probabilidad uniforme en el rango comprendido entre los
valores extremos. En la figura~\ref{FigMonteCarlo} vemos el esquema de un
ejemplo con dos variables.

\PICTURE{210}{200}
{
	\put(20,10){\vector(0,1){180}}
	\put(20,10){\vector(1,0){180}}
	\put(10,190){$y$}
	\put(200,0){$x$}
	\put(59,159){\circle*{2}}
	\put(153,73){\circle*{2}}
	\put(98,67){\circle*{2}}
	\put(129,154){\circle*{2}}
	\put(128,104){\circle*{2}}
	\put(119,131){\circle*{2}}
	\put(136,77){\circle*{2}}
	\put(60,102){\circle*{2}}
	\put(87,97){\circle*{2}}
	\put(65,66){\circle*{2}}
	\put(80,43){\circle*{2}}
	\put(153,63){\circle*{2}}
	\put(147,109){\circle*{2}}
	\put(99,119){\circle*{2}}
	\put(61,107){\circle*{2}}
	\put(54,75){\circle*{2}}
	\put(117,47){\circle*{2}}
	\put(116,127){\circle*{2}}
	\put(51,125){\circle*{2}}
	\put(52,123){\circle*{2}}
	\put(100,55){\circle*{2}}
	\put(74,64){\circle*{2}}
	\put(55,49){\circle*{2}}
	\put(49,105){\circle*{2}}
	\put(146,75){\circle*{2}}	
	\qbezier[50](50,10)(50,85)(50,160)
	\put(40,0){$x_{\min}$}
	\qbezier[50](170,10)(170,85)(170,160)
	\put(160,0){$x_{\max}$}
	\qbezier[50](20,40)(95,40)(170,40)
	\put(0,37){$y_{\min}$}
	\qbezier[50](20,160)(95,160)(170,160)
	\put(0,157){$y_{\max}$}
}{Monte-Carlo brutal force method with two variables}{FigMonteCarlo}

\subsection{Iterative algorithm applied to brutal force methods}

CALIBRATOR allows to iterate both brutal force methods (sweep or Monte-Carlo) to
increase the convergence. In this case, the bests results of the previous
iteration are used to force new intervals in the variables. Then, para
$N_{bests}^j$ el subconjunto de las mejores simulaciones de la $j$-ésima
iteración, definimos las siguientes magnitudes:
\begin{description}
\item{$\displaystyle x_{\max}^b=\max_{i\in N_{bests}}x_i^j$}: máximo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\item{$\displaystyle x_{\min}^b=\max_{i\in N_{bests}}x_i^j$}: mínimo valor de la
	variable $x$ en el subconjunto de las mejores simulaciones de la iteración
	$j$-ésima.
\end{description}
El nuevo intervalo en la variable $x$ en el que se simulará la siguiente
iteración estará comprendido entre:
\[
	x_{\max}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		+\left(x_{\max}^b-x_{\min}^b\right)(1+tolerance)}{2},
\]
\[
	x_{\min}^{j+1}=\frac{x_{\max}^b+x_{\min}^b
		-\left(x_{\max}^b-x_{\min}^b\right)(1+tolerance)}{2},
\]
\EQ{x_i^{j+1}\in\left[x_{\min}^{j+1},\;x_{\max}^{j+1}\right].}
{EqIterationInterval}
En la figura~\ref{FigIterative} se ilustra el procedimiento con el que el
algoritmo iterativo modifica los intervalos de las variables para incrementar la
convergencia.

\PICTURE{210}{400}
{
	\small
	\multiput(0,0)(0,200){2}
	{
		\put(20,10){\vector(0,1){180}}
		\put(20,10){\vector(1,0){180}}
		\put(10,190){$y$}
		\put(200,0){$x$}
	}
	\put(90,380){1st iteration}
	\put(50,370){*: bests results}
	\put(59,359){\circle*{2}}
	\put(153,273){\circle*{2}}
	\put(98,267){*}
	\put(129,354){\circle*{2}}
	\put(128,304){*}
	\put(119,331){\circle*{2}}
	\put(136,277){\circle*{2}}
	\put(60,302){\circle*{2}}
	\put(87,297){*}
	\put(65,266){\circle*{2}}
	\put(80,243){\circle*{2}}
	\put(153,263){\circle*{2}}
	\put(147,309){\circle*{2}}
	\put(99,319){*}
	\put(61,307){\circle*{2}}
	\put(54,275){\circle*{2}}
	\put(117,247){\circle*{2}}
	\put(116,327){\circle*{2}}
	\put(51,325){\circle*{2}}
	\put(52,323){\circle*{2}}
	\put(100,255){\circle*{2}}
	\put(74,264){\circle*{2}}
	\put(55,249){\circle*{2}}
	\put(49,305){\circle*{2}}
	\put(146,275){\circle*{2}}	
	\qbezier[50](50,210)(50,285)(50,360)
	\put(40,200){$x_{\min}^1$}
	\qbezier[50](170,210)(170,285)(170,360)
	\put(160,200){$x_{\max}^1$}
	\qbezier[50](20,240)(95,240)(170,240)
	\put(0,237){$y_{\min}^1$}
	\qbezier[50](20,360)(95,360)(170,360)
	\put(0,357){$y_{\max}^1$}
	\qbezier[21](89,272)(109.5,272)(130,272)
	\qbezier[21](89,324)(109.5,324)(130,324)
	\qbezier[26](89,272)(89,298)(89,324)
	\qbezier[26](130,272)(130,298)(130,324)
	\put(89,267){\vector(1,0){41}}
	\put(130,267){\vector(-1,0){41}}
	\put(90,255){$x_{\max}^b-x_{\min}^b$}
	\put(84.9,215){\vector(1,0){49.2}}
	\put(134.1,215){\vector(-1,0){49.2}}
	\put(90,220){$x_{\max}^2-x_{\min}^2$}
	\qbezier[20](89,272)(86.95,241)(84.9,210)
	\qbezier[20](130,272)(132.05,241)(134.1,210)
	\qbezier[23](89,272)(54.5,269.4)(20,266.8)
	\qbezier[23](89,324)(54.5,326.6)(20,329.2)
	\put(80,180){2nd iteration}
	\put(92,123){\circle*{2}}
	\put(131,83){\circle*{2}}
	\put(108,80){\circle*{2}}
	\put(121,121){\circle*{2}}
	\put(121,97){\circle*{2}}
	\put(117,110){\circle*{2}}
	\put(124,84){\circle*{2}}
	\put(93,96){\circle*{2}}
	\put(104,94){\circle*{2}}
	\put(95,79){\circle*{2}}
	\put(101,68){\circle*{2}}
	\put(131,78){\circle*{2}}
	\put(129,100){\circle*{2}}
	\put(109,104){\circle*{2}}
	\put(93,98){\circle*{2}}
	\put(90,83){\circle*{2}}
	\put(116,70){\circle*{2}}
	\put(116,108){\circle*{2}}
	\put(89,107){\circle*{2}}
	\put(90,106){\circle*{2}}
	\put(109,74){\circle*{2}}
	\put(99,78){\circle*{2}}
	\put(91,71){\circle*{2}}
	\put(89,98){\circle*{2}}
	\put(128,83){\circle*{2}}
	\qbezier[40](84.9,10)(84.9,69.6)(84.9,129.2)
	\put(74.9,0){$x_{\min}^2$}
	\qbezier[40](134.1,10)(134.1,69.6)(134.1,129.2)
	\put(124.1,0){$x_{\max}^2$}
	\qbezier[35](20,129.2)(77.05,129.2)(134.1,129.2)
	\put(0,126.2){$y_{\max}^2$}
	\qbezier[35](20,66.8)(77.05,66.8)(134.1,66.8)
	\put(0,63.8){$y_{\min}^2$}
}{Iterative algorithm applied to a Monte-Carlo brutal force method with two
variables}{FigIterative}

\subsection{Genetic method}

El algoritmo genético implementado en CALIBRATOR 
Los algoritmos están inspirados en \cite{gaul}, aunque han sido completamente
reescritos con muchas simplificaciones y haciendo uso de modernas librerías
externas. El código del algoritmo está publicado de forma independiente en
\cite{genetic} y también es open source bajo licencia de tipo BSD. Dada una
población 

\subsubsection{Mutation algorithm}

\subsubsection{Reproduction algorithm}


\subsubsection{Adaptation algorithm}

\section{Implementation}

\subsection{External libraries}

CALIBRATOR hace uso de las siguientes librerías externas:

\begin{itemize}
\item\cite{libxml}: librería open source requerida para leer el fichero
	de entrada que usa el formato XML.
\item\cite{gsl}: librería científica open source requerida para generar
	los números pseudo-aleatorios que usan los algoritmos genético y de
	Monte-Carlo.
\item\cite{glib}: librería open source requerida para implementar algunos
	tipos de datos y las tareas con las que el programa paraleliza el uso de los
	múltiples procesadores de la máquina.
\item\cite{openmpi,mpich}: librerías open source opcionales. En
	el caso de estar alguna de ellas instaladas en el sistema, el programa la
	utiliza para permitir el uso paralelizado en múltiple máquinas.
\end{itemize}

\subsection{Command line format}

\begin{itemize}

\item Command line in sequential mode (where X is the number of threads to
execute):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item Command line in parallelized mode (where X is the number of threads to
open in every node):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ mpirun [MPI options] ./calibrator [-nthreads X] input_file.xml
\end{lstlisting}

\item The sintaxis of the simulator has to be:
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./simulator_name input_file_1 [input_file_2] [...] output_file
\end{lstlisting}
They are two options for the ouput file. It can begin with a number indicating
the objective function value or it can be a results file that has to be
evaluated by an external program (the evaluator) comparing with an experimental
file.

\item In the last option of the former point, the sintaxis of the program to
evaluate the objetive function has to be (where the results file has to begin
with the objective function value):
\begin{lstlisting}[language=bash,basicstyle=\scriptsize]
$ ./evaluator_name simulated_file experimental_file results_file
\end{lstlisting}

\end{itemize}

\subsubsection{Input data file}

The format of the input data file is:
\begin{lstlisting}[language=xml,basicstyle=\scriptsize]
<?xml version="1.0"/>
<calibrate simulator="simulator_name" evaluator="evaluator_name"
	algorithm="algorithm_type" simulations="simulations_number"
	iterations="iterations_number" tolerance="tolerance_value"
	bests="bests_number">
	<experiment name="data_file_1" template1="template_1_1"
		template2="template_1_2" .../>
	...
	<experiment name="data_file_N" template1="template_N_1"
		template2="template_N_2" .../>
	<variable name="variable_1" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
	...
	<variable name="variable_M" minimum="min_value"
		maximum="max_value" format="c_string_format"
		sweeps="sweeps_number" bits="bits_number"/>
</calibrate>
\end{lstlisting}

The main XML node has to begin with key label "calibrate". The available fields
are:
\begin{description}
\item{simulator}: to indicate the simulator program.
\item{evaluator}: optional. It specify the evaluator program if required.
\item{algorithm}: to set the optimization algorithm. Three value are available:
	\begin{description}
	\item{sweep}: sweep brutal force algorithm. Requires on each variable:
		\begin{description}
		\item{sweeps}: number of sweeps to generate on each variable in every
			experiment.
		\end{description}
	\item{Monte-Carlo}: Monte-Carlo brutal force algorithm. Requires on the main
		XML node:
		\begin{description}
		\item{simulations}: number of simulations to run on each iteration in
			every experiment.
		\end{description}
	\item{genetic}: genetic algorithm. Requires the following parameters in the
		main XML node:
		\begin{description}
		\item{population}: number of population entities.
		\item{generations}: number of generations.
		\item{mutation}: mutation ratio.
		\item{reproduction}: reproduction ratio.
		\item{adaptation}: adaptation ratio.
		\end{description}
	And on each variable:
		\begin{description}
		\item{bits}: number of bits to encode each variable.
		\end{description}
	\end{description}
\item{iterations}: number of iterations (default 1) to perform the iterative
algorithm. It applies only on sweep and Monte-Carlo methods.
\item{bests}: number of bests simulations to calculate convergence interval on
next iteration (default 1). It applies only on iterative algorithm.
\item{tolerance}: tolerance parameter to increase convergence interval (default
0). It applies only on iterative algorithm.
\end{description}

\section{Practical applications}

\subsection{Calibration of empirical parameters on surface irrigation}

\subsection{Optimization of a canal management}

\subsection{Calibration of empirical parameters on sprinkler irrigation}

\section{Conclusions}

\bibliography{bib}

\end{document}

